//+------------------------------------------------------------------+
//| SWIECA_BUY_CLOSE_OR_BUFFER.mq5                                   |
//+------------------------------------------------------------------+
#property strict

#include <Trade/Trade.mqh>
CTrade trade;

input double Lots = 0.1;
input int SL_Pips = 50;
input int TP_Pips = 50;
input int MaxCandlesWait = 3;
input int EntryBufferPips = 20;   // tylko do wejÅ›cia intrabar

datetime lastBar = 0;

// setup BUY
double rememberedBearHigh = 0.0;
bool   haveBearHigh = false;
int    candlesWaited = 0;

double Pip()
{
   if(_Digits == 3 || _Digits == 5)
      return _Point * 10;
   return _Point;
}

void ResetSetup()
{
   haveBearHigh = false;
   rememberedBearHigh = 0.0;
   candlesWaited = 0;
}

void StartNewSetup(double high)
{
   rememberedBearHigh = high;
   haveBearHigh = true;
   candlesWaited = 0;
}

// =========================
// INTRABAR â€“ szybkie wejÅ›cie
// =========================
void CheckIntrabarBreak()
{
   if(!haveBearHigh) return;
   if(PositionsTotal() > 0) return;

   double pip = Pip();
   double trigger = rememberedBearHigh + EntryBufferPips * pip;

   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

   if(ask >= trigger)
   {
      double sl = ask - SL_Pips * pip;
      double tp = ask + TP_Pips * pip;

      trade.Buy(Lots, _Symbol, ask, sl, tp,
                "BUY intrabar buffer");

      ResetSetup();
   }
}

void OnTick()
{
   // ðŸ”¹ zawsze sprawdzaj szybkie wybicie
   CheckIntrabarBreak();

   // ðŸ”¹ logika Å›wiecowa tylko na nowej Å›wiecy
   datetime barTime = iTime(_Symbol, _Period, 0);
   if(barTime == lastBar) return;
   lastBar = barTime;

   if(PositionsTotal() > 0) return;

   double open1  = iOpen(_Symbol, _Period, 1);
   double close1 = iClose(_Symbol, _Period, 1);
   double high1  = iHigh(_Symbol, _Period, 1);

   bool bearish = (close1 < open1);

   // ðŸ” NOWA Å›wieca spadkowa â†’ nowy setup
   if(bearish)
   {
      StartNewSetup(high1);
      return;
   }

   // jeÅ›li setup aktywny
   if(haveBearHigh)
   {
      candlesWaited++;

      // âŒ timeout
      if(candlesWaited > MaxCandlesWait)
      {
         ResetSetup();
         return;
      }

      // âœ… BUY NA ZAMKNIÄ˜CIU ÅšWIECY (BEZ BUFORA)
      if(close1 > rememberedBearHigh)
      {
         double pip = Pip();
         double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

         double sl = price - SL_Pips * pip;
         double tp = price + TP_Pips * pip;

         trade.Buy(Lots, _Symbol, price, sl, tp,
                   "BUY candle close");

         ResetSetup();
         return;
      }
   }
}
