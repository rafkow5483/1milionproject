//+------------------------------------------------------------------+
//|   MA_Pullback_BuySellStop_OnePerCross.mq5                        |
//|   BUY = lustrzane odbicie SELL                                   |
//|   SELL: cross-down, cofka w górę ≥ X pips -> SELL STOP na dołku  |
//|   BUY : cross-up,   cofka w dół ≥ X pips -> BUY  STOP na szczycie|
//|   Dodano: limit maks. spreadu + strażnik oczekujących            |
//+------------------------------------------------------------------+
#property strict
#include <Trade/Trade.mqh>
CTrade trade;

//=========================== Parametry =============================//
input ENUM_MA_METHOD InpMaMethod        = MODE_EMA; // EMA/SMA/SMMA/LWMA
input int            InpFastPeriod      = 5;        // szybka MA
input int            InpSlowPeriod      = 20;       // wolna MA
input int            InpPullbackPips    = 5;        // min cofka (pipsy)
input double         InpLots            = 0.10;     // wolumen
input int            InpSL_Pips         = 0;        // SL (pipsy; 0 = brak)
input int            InpTP_Pips         = 0;        // TP (pipsy; 0 = brak)
input double         InpBreakLowPips    = 0.0;      // przebicie Low dla SELL STOP
input double         InpBreakHighPips   = 0.0;      // przebicie High dla BUY  STOP
input int            InpExpireMinutes   = 240;      // wygaśnięcie oczekujących (0=GTC)
input long           InpMagic           = 20250810; // magic
input int            InpSlippagePts     = 10;       // maks. odchylenie (punkty)
input bool           InpOnePosPerCross  = true;     // jedna pozycja na przecięcie

// --- Nowe: kontrola spreadu ---
input double         InpMaxSpreadPips   = 2.0;      // maks. spread (pipsy; 0 = brak limitu)
input bool           InpGuardPendingsBySpread = true; // usuń oczekujące gdy spread > limit

// tryb kierunku
enum DirectionMode { SELL_ONLY=0, BUY_ONLY=1, BOTH=2 };
input DirectionMode  InpDirection       = BOTH;     // które kierunki aktywne

//=========================== Zmienne stanu =========================//
int      fastHandle=-1, slowHandle=-1;

// czasy potwierdzonych przecięć
datetime lastCrossDownTime=0;
datetime lastCrossUpTime=0;

// SELL stan
bool     sellArmed=false;         // po cross-down: szukamy cofki w górę
double   swingLow=0.0;            // dołek poprzedzający cofkę
bool     pullbackSeenSell=false;  // cofka ≥ X pips dla SELL?
ulong    pendingSellTicket=0;     // ticket SELL STOP
bool     tradedThisCrossDown=false; // JEDNA pozycja dla danego cross-down

// BUY stan
bool     buyArmed=false;          // po cross-up: szukamy cofki w dół
double   swingHigh=0.0;           // szczyt poprzedzający cofkę
bool     pullbackSeenBuy=false;   // cofka ≥ X pips dla BUY?
ulong    pendingBuyTicket=0;      // ticket BUY STOP
bool     tradedThisCrossUp=false; // JEDNA pozycja dla danego cross-up

//=========================== Pomocnicze ============================//
double Pip(){ return (_Digits==3 || _Digits==5) ? 10.0*_Point : _Point; }
double N(double p){ return NormalizeDouble(p,_Digits); }
double SpreadPips()
{
   double b=SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double a=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   return (a-b)/Pip();
}

bool SpreadOK()
{
   if(InpMaxSpreadPips<=0.0) return true;
   double sp = SpreadPips();
   if(sp <= InpMaxSpreadPips) return true;
   PrintFormat("Spread %.1f pips > limit %.1f pips — wstrzymuję działanie.",
               sp, InpMaxSpreadPips);
   return false;
}

bool PrepareMAs()
{
   if(fastHandle==-1)
      fastHandle=iMA(_Symbol,PERIOD_CURRENT,InpFastPeriod,0,InpMaMethod,PRICE_CLOSE);
   if(slowHandle==-1)
      slowHandle=iMA(_Symbol,PERIOD_CURRENT,InpSlowPeriod,0,InpMaMethod,PRICE_CLOSE);
   return (fastHandle!=INVALID_HANDLE && slowHandle!=INVALID_HANDLE);
}

bool ReadMA(int shift,double &f,double &s)
{
   if(!PrepareMAs()) return false;
   double fb[3], sb[3];
   if(CopyBuffer(fastHandle,0,shift,3,fb)<3) return false;
   if(CopyBuffer(slowHandle,0,shift,3,sb)<3) return false;
   f=fb[0]; s=sb[0]; return true;
}

bool CrossDownConfirmed(datetime &barTime)
{
   double f2,s2,f1,s1;
   if(!ReadMA(2,f2,s2) || !ReadMA(1,f1,s1)) return false;
   if(f2> s2 && f1< s1)
   {
      MqlRates r[]; if(CopyRates(_Symbol,PERIOD_CURRENT,1,1,r)==1){ barTime=r[0].time; return true; }
   }
   return false;
}

bool CrossUpConfirmed(datetime &barTime)
{
   double f2,s2,f1,s1;
   if(!ReadMA(2,f2,s2) || !ReadMA(1,f1,s1)) return false;
   if(f2< s2 && f1> s1)
   {
      MqlRates r[]; if(CopyRates(_Symbol,PERIOD_CURRENT,1,1,r)==1){ barTime=r[0].time; return true; }
   }
   return false;
}

void ResetAllState(bool keepCrossTimes=false)
{
   // SELL
   sellArmed=false; swingLow=0.0; pullbackSeenSell=false; pendingSellTicket=0;
   if(!keepCrossTimes) lastCrossDownTime=0;
   tradedThisCrossDown=false;

   // BUY
   buyArmed=false; swingHigh=0.0; pullbackSeenBuy=false; pendingBuyTicket=0;
   if(!keepCrossTimes) lastCrossUpTime=0;
   tradedThisCrossUp=false;
}

void CancelOurPendings()
{
   for(int i=OrdersTotal()-1;i>=0;--i)
   {
      ulong t=OrderGetTicket(i); if(!t) continue;
      if(!OrderSelect(t)) continue;
      if(OrderGetInteger(ORDER_MAGIC)!=InpMagic) continue;

      ENUM_ORDER_TYPE typ=(ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
      if(typ==ORDER_TYPE_SELL_STOP || typ==ORDER_TYPE_BUY_STOP)
         trade.OrderDelete(t);
   }
   pendingSellTicket=0;
   pendingBuyTicket=0;
}

//---------------------- Składanie SELL STOP ------------------------//
bool PlaceSellStopAtSwingLow()
{
   if(InpOnePosPerCross && tradedThisCrossDown) return false;

   // kontrola spreadu przed złożeniem
   if(!SpreadOK()) return false;

   double pp=Pip();
   double price = N(swingLow - InpBreakLowPips*pp);
   double sl=0.0, tp=0.0;
   if(InpSL_Pips>0) sl=N(price + InpSL_Pips*pp);
   if(InpTP_Pips>0) tp=N(price - InpTP_Pips*pp);
   datetime exp=(InpExpireMinutes>0)?(TimeCurrent()+InpExpireMinutes*60):0;

   trade.SetExpertMagicNumber(InpMagic);
   trade.SetDeviationInPoints(InpSlippagePts);

   bool ok=trade.SellStop(InpLots,price,_Symbol,sl,tp,(exp>0?ORDER_TIME_SPECIFIED:ORDER_TIME_GTC),exp);
   if(ok){
      pendingSellTicket=trade.ResultOrder();
      PrintFormat("SELL STOP ok: price=%.5f sl=%.5f tp=%.5f (swingLow=%.5f)",
                  price,sl,tp,swingLow);
   }else{
      PrintFormat("SELL STOP błąd: ret=%d (%s)", (int)trade.ResultRetcode(),
                  trade.ResultRetcodeDescription());
   }
   return ok;
}

//---------------------- Składanie BUY STOP -------------------------//
bool PlaceBuyStopAtSwingHigh()
{
   if(InpOnePosPerCross && tradedThisCrossUp) return false;

   // kontrola spreadu przed złożeniem
   if(!SpreadOK()) return false;

   double pp=Pip();
   double price = N(swingHigh + InpBreakHighPips*pp);
   double sl=0.0, tp=0.0;
   if(InpSL_Pips>0) sl=N(price - InpSL_Pips*pp);
   if(InpTP_Pips>0) tp=N(price + InpTP_Pips*pp);
   datetime exp=(InpExpireMinutes>0)?(TimeCurrent()+InpExpireMinutes*60):0;

   trade.SetExpertMagicNumber(InpMagic);
   trade.SetDeviationInPoints(InpSlippagePts);

   bool ok=trade.BuyStop(InpLots,price,_Symbol,sl,tp,(exp>0?ORDER_TIME_SPECIFIED:ORDER_TIME_GTC),exp);
   if(ok){
      pendingBuyTicket=trade.ResultOrder();
      PrintFormat("BUY  STOP ok: price=%.5f sl=%.5f tp=%.5f (swingHigh=%.5f)",
                  price,sl,tp,swingHigh);
   }else{
      PrintFormat("BUY  STOP błąd: ret=%d (%s)", (int)trade.ResultRetcode(),
                  trade.ResultRetcodeDescription());
   }
   return ok;
}

//=============================== OnInit ============================//
int OnInit(){ ResetAllState(); return(INIT_SUCCEEDED); }

//=============================== OnTick ============================//
void OnTick()
{
   if(!PrepareMAs()) return;

   double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double pp=Pip();

   //--- 0) Strażnik: jeśli spread > limit, usuwaj oczekujące (opcja)
   if(InpMaxSpreadPips>0.0 && InpGuardPendingsBySpread)
   {
      double sp=SpreadPips();
      if(sp > InpMaxSpreadPips)
      {
         if(pendingSellTicket!=0)
         {
            trade.OrderDelete(pendingSellTicket);
            pendingSellTicket=0;
            pullbackSeenSell=false;
            swingLow=bid;
            PrintFormat("Spread %.1f > %.1f — usuwam SELL STOP i czekam na poprawę.",
                        sp, InpMaxSpreadPips);
         }
         if(pendingBuyTicket!=0)
         {
            trade.OrderDelete(pendingBuyTicket);
            pendingBuyTicket=0;
            pullbackSeenBuy=false;
            swingHigh=ask;
            PrintFormat("Spread %.1f > %.1f — usuwam BUY STOP i czekam na poprawę.",
                        sp, InpMaxSpreadPips);
         }
      }
   }

   //--- 1) Nowe przecięcia
   datetime ctDown=0, ctUp=0;

   // Cross DOWN -> przygotuj SELL (jeśli tryb pozwala) i wyczyść BUY
   if(CrossDownConfirmed(ctDown) && ctDown!=lastCrossDownTime)
   {
      CancelOurPendings();
      ResetAllState(true);
      lastCrossDownTime=ctDown;

      if(InpDirection!=BUY_ONLY){
         sellArmed=true;
         tradedThisCrossDown=false;
         swingLow = bid;
         Print("Cross DOWN potwierdzony -> SELL: szukam dołka i cofki ≥ ", InpPullbackPips, " pips.");
      }else{
         sellArmed=false;
      }
   }

   // Cross UP -> przygotuj BUY (jeśli tryb pozwala) i wyczyść SELL
   if(CrossUpConfirmed(ctUp) && ctUp!=lastCrossUpTime)
   {
      CancelOurPendings();
      ResetAllState(true);
      lastCrossUpTime=ctUp;

      if(InpDirection!=SELL_ONLY){
         buyArmed=true;
         tradedThisCrossUp=false;
         swingHigh = ask;
         Print("Cross UP potwierdzony -> BUY: szukam szczytu i cofki ≥ ", InpPullbackPips, " pips.");
      }else{
         buyArmed=false;
      }
   }

   //--- 2) SELL — pilnowanie cofki w górę i wystawienie SELL STOP
   if(sellArmed && !(InpOnePosPerCross && tradedThisCrossDown))
   {
      if(!pullbackSeenSell)
      {
         if(swingLow==0.0 || bid < swingLow)
            swingLow=bid;

         double triggerUp = swingLow + InpPullbackPips*pp;
         if(ask >= triggerUp)
         {
            pullbackSeenSell=true;
            PrintFormat("SELL: cofka ≥ %d pips (swingLow=%.5f). Próba wystawienia SELL STOP.", InpPullbackPips, swingLow);
            if(!PlaceSellStopAtSwingLow())
               pullbackSeenSell=false; // spróbuj ponownie
         }
      }

      // jeśli oczekujące zniknęło — sprawdź co dalej
      if(pendingSellTicket!=0 && !OrderSelect(pendingSellTicket))
      {
         pendingSellTicket=0;
         if(!(InpOnePosPerCross && tradedThisCrossDown))
         {
            pullbackSeenSell=false;
            swingLow=bid;
         }
      }
   }

   //--- 3) BUY — pilnowanie cofki w dół i wystawienie BUY STOP
   if(buyArmed && !(InpOnePosPerCross && tradedThisCrossUp))
   {
      if(!pullbackSeenBuy)
      {
         if(swingHigh==0.0 || ask > swingHigh)
            swingHigh=ask;

         double triggerDn = swingHigh - InpPullbackPips*pp;
         if(bid <= triggerDn)
         {
            pullbackSeenBuy=true;
            PrintFormat("BUY: cofka ≥ %d pips (swingHigh=%.5f). Próba wystawienia BUY STOP.", InpPullbackPips, swingHigh);
            if(!PlaceBuyStopAtSwingHigh())
               pullbackSeenBuy=false; // spróbuj ponownie
         }
      }

      // jeśli oczekujące zniknęło — sprawdź co dalej
      if(pendingBuyTicket!=0 && !OrderSelect(pendingBuyTicket))
      {
         pendingBuyTicket=0;
         if(!(InpOnePosPerCross && tradedThisCrossUp))
         {
            pullbackSeenBuy=false;
            swingHigh=ask;
         }
      }
   }
}

//=========================== OnTradeTransaction ====================//
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   if(!InpOnePosPerCross) return;

   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
   {
      ulong deal = trans.deal;
      if(deal==0) return;
      if(!HistoryDealSelect(deal)) return;

      string sym   = HistoryDealGetString(deal, DEAL_SYMBOL);
      long   dtype = (long)HistoryDealGetInteger(deal, DEAL_TYPE);
      long   dmag  = (long)HistoryDealGetInteger(deal, DEAL_MAGIC);

      if(sym==_Symbol && dmag==InpMagic)
      {
         if(dtype==DEAL_TYPE_SELL)
         {
            tradedThisCrossDown = true;
            sellArmed = false;
            CancelOurPendings();
            Print("SELL otwarty -> blokuję dalsze wejścia do kolejnego cross-down.");
         }
         else if(dtype==DEAL_TYPE_BUY)
         {
            tradedThisCrossUp = true;
            buyArmed = false;
            CancelOurPendings();
            Print("BUY otwarty -> blokuję dalsze wejścia do kolejnego cross-up.");
         }
      }
   }
}

//=============================== OnDeinit ===========================//
void OnDeinit(const int reason){ /* nic */ }

