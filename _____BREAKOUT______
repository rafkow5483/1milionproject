//+------------------------------------------------------------------+
//|            MA_Pullback_SellStop_OnePerCross.mq5                  |
//|  Jedna pozycja na jedno przecięcie MA(5) < MA(20).               |
//|  Po cofce >= X pips ustaw SELL STOP na dołku tej cofki.          |
//+------------------------------------------------------------------+
#property strict
#include <Trade/Trade.mqh>
CTrade trade;

//=========================== Parametry =============================//
input ENUM_MA_METHOD InpMaMethod        = MODE_EMA; // EMA/SMA/SMMA/LWMA
input int            InpFastPeriod      = 5;        // szybka MA
input int            InpSlowPeriod      = 20;       // wolna MA
input int            InpPullbackPips    = 5;        // min cofka w górę (pipsy)
input double         InpLots            = 0.10;     // wolumen
input int            InpSL_Pips         = 0;        // SL (pipsy; 0 = brak)
input int            InpTP_Pips         = 0;        // TP (pipsy; 0 = brak)
input double         InpBreakLowPips    = 0.0;      // przebicie low dla SELL STOP (pipsy)
input int            InpExpireMinutes   = 240;      // wygaśnięcie oczekującego (0=GTC)
input long           InpMagic           = 20250810; // magic
input int            InpSlippagePts     = 10;       // maks. odchylenie (punkty)
input bool           InpOnePosPerCross  = true;     // jedna pozycja na przecięcie

//=========================== Zmienne stanu =========================//
int      fastHandle=-1, slowHandle=-1;
datetime lastCrossTime=0;     // czas świecy z potwierdzonym cross-down
bool     armed=false;         // po cross-down: szukamy cofki
double   swingLow=0.0;        // dołek poprzedzający cofkę
bool     pullbackSeen=false;  // cofka >= X pips już była?
ulong    pendingTicket=0;     // ticket SELL STOP
bool     tradedThisCross=false; // POZYCJA już zrobiona dla TEGO crossa?

//=========================== Pomocnicze ============================//
double Pip(){ return (_Digits==3 || _Digits==5) ? 10.0*_Point : _Point; }
double N(double p){ return NormalizeDouble(p,_Digits); }

bool PrepareMAs()
{
   if(fastHandle==-1)
      fastHandle=iMA(_Symbol,PERIOD_CURRENT,InpFastPeriod,0,InpMaMethod,PRICE_CLOSE);
   if(slowHandle==-1)
      slowHandle=iMA(_Symbol,PERIOD_CURRENT,InpSlowPeriod,0,InpMaMethod,PRICE_CLOSE);
   return (fastHandle!=INVALID_HANDLE && slowHandle!=INVALID_HANDLE);
}

bool ReadMA(int shift,double &f,double &s)
{
   if(!PrepareMAs()) return false;
   double fb[3], sb[3];
   if(CopyBuffer(fastHandle,0,shift,3,fb)<3) return false;
   if(CopyBuffer(slowHandle,0,shift,3,sb)<3) return false;
   f=fb[0]; s=sb[0]; return true;
}

bool CrossDownConfirmed(datetime &barTime)
{
   double f2,s2,f1,s1;
   if(!ReadMA(2,f2,s2) || !ReadMA(1,f1,s1)) return false;
   if(f2> s2 && f1< s1)
   {
      MqlRates r[]; if(CopyRates(_Symbol,PERIOD_CURRENT,1,1,r)==1){ barTime=r[0].time; return true; }
   }
   return false;
}

bool CrossUpConfirmed()
{
   double f2,s2,f1,s1;
   if(!ReadMA(2,f2,s2) || !ReadMA(1,f1,s1)) return false;
   return (f2< s2 && f1> s1);
}

void ResetState(bool keepLastCross=false)
{
   armed=false;
   swingLow=0.0;
   pullbackSeen=false;
   pendingTicket=0;
   if(!keepLastCross) lastCrossTime=0;
   // tradedThisCross zostawiamy tak jak jest — resetujemy dopiero przy nowym crossie
}

void CancelOurPendings()
{
   for(int i=OrdersTotal()-1;i>=0;--i)
   {
      ulong t=OrderGetTicket(i); if(!t) continue;
      if(!OrderSelect(t)) continue;
      if(OrderGetInteger(ORDER_MAGIC)!=InpMagic) continue;
      if(OrderGetInteger(ORDER_TYPE)==ORDER_TYPE_SELL_STOP)
         trade.OrderDelete(t);
   }
   pendingTicket=0;
}

bool PlaceSellStopAtSwingLow()
{
   if(InpOnePosPerCross && tradedThisCross) return false; // już handlowaliśmy na tym crossie

   double pp=Pip();
   double price = N(swingLow - InpBreakLowPips*pp);
   double sl=0.0, tp=0.0;
   if(InpSL_Pips>0) sl=N(price + InpSL_Pips*pp);
   if(InpTP_Pips>0) tp=N(price - InpTP_Pips*pp);
   datetime exp=(InpExpireMinutes>0)?(TimeCurrent()+InpExpireMinutes*60):0;

   trade.SetExpertMagicNumber(InpMagic);
   trade.SetDeviationInPoints(InpSlippagePts);

   bool ok=trade.SellStop(InpLots,price,_Symbol,sl,tp,(exp>0?ORDER_TIME_SPECIFIED:ORDER_TIME_GTC),exp);
   if(ok){
      pendingTicket=trade.ResultOrder();
      PrintFormat("SELL STOP ok: price=%.5f sl=%.5f tp=%.5f (swingLow=%.5f)",
                  price,sl,tp,swingLow);
   }else{
      PrintFormat("SELL STOP błąd: ret=%d (%s)", (int)trade.ResultRetcode(),
                  trade.ResultRetcodeDescription());
   }
   return ok;
}

//=============================== OnInit ============================//
int OnInit(){ ResetState(); return(INIT_SUCCEEDED); }

//=============================== OnTick ============================//
void OnTick()
{
   if(!PrepareMAs()) return;

   // 1) Nowy cross-down uzbraja strategię i resetuje licznik "jedna pozycja"
   datetime ct=0;
   if(CrossDownConfirmed(ct) && ct!=lastCrossTime)
   {
      CancelOurPendings();
      ResetState(true);
      lastCrossTime=ct;
      armed=true;
      tradedThisCross=false; // od tej chwili możemy zrobić dokładnie jedną pozycję
      swingLow = SymbolInfoDouble(_Symbol,SYMBOL_BID);
      Print("Cross DOWN potwierdzony -> szukam dołka i cofki ≥ ", InpPullbackPips, " pips.");
   }

   // 2) Cross-up: czyścimy i czekamy na kolejny cross-down
   if(CrossUpConfirmed())
   {
      CancelOurPendings();
      ResetState();
      Print("Cross UP -> reset.");
      return;
   }

   if(!armed) return;
   if(InpOnePosPerCross && tradedThisCross) return; // już zagraliśmy na tym crossie

   double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double pp=Pip();

   // 3) Dołek cofki — aktualizuj dopóki nie widzieliśmy cofki
   if(!pullbackSeen)
   {
      if(swingLow==0.0 || bid < swingLow)
         swingLow=bid;

      double trigger = swingLow + InpPullbackPips*pp;
      if(ask >= trigger)
      {
         pullbackSeen=true;
         PrintFormat("Cofka ≥ %d pips wykryta (swingLow=%.5f). Ustawiam SELL STOP.", InpPullbackPips, swingLow);
         if(!PlaceSellStopAtSwingLow())
         {
            pullbackSeen=false; // jeśli nie udało się złożyć zlecenia, próbuj dalej
         }
      }
   }

   // 4) Jeśli oczekujące zniknęło, sprawdź czy była transakcja (obsłuży to też OnTradeTransaction)
   if(pendingTicket!=0 && !OrderSelect(pendingTicket))
   {
      // zlecenie już nie istnieje: mogło się wypełnić lub wygasnąć/anulować
      pendingTicket=0;
      if(!(InpOnePosPerCross && tradedThisCross))
      {
         // jeśli nie zagraliśmy jeszcze na tym crossie, poluj dalej na kolejną cofkę
         pullbackSeen=false;
         swingLow=bid;
      }
   }
}

//=========================== OnTradeTransaction ====================//
// Ustaw 'tradedThisCross=true' dokładnie w momencie otwarcia pozycji SELL
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   if(!InpOnePosPerCross) return;

   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
   {
      ulong deal = trans.deal;
      if(deal==0) return;
      if(!HistoryDealSelect(deal)) return;

      string sym   = HistoryDealGetString(deal, DEAL_SYMBOL);
      long   dtype = (long)HistoryDealGetInteger(deal, DEAL_TYPE);
      long   dmag  = (long)HistoryDealGetInteger(deal, DEAL_MAGIC);

      if(sym==_Symbol && dmag==InpMagic && dtype==DEAL_TYPE_SELL)
      {
         tradedThisCross = true;   // zrobiona JEDNA pozycja dla tego crossa
         armed = false;            // przestajemy polować aż do następnego cross-down
         CancelOurPendings();      // na wszelki wypadek usuń oczekujące
         Print("Pozycja SELL otwarta -> blokuję dalsze wejścia do kolejnego przecięcia.");
      }
   }
}

//=============================== OnDeinit ===========================//
void OnDeinit(const int reason){ /* nic */ }




