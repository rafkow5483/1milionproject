//+------------------------------------------------------------------+
//|   MA_Pullback_BuySellStop_OnePerCross.mq5                        |
//|   BUY = lustrzane odbicie SELL                                   |
//|   SELL: cross-down, cofka w górę ≥ X pips -> SELL STOP na dołku  |
//|   BUY : cross-up,   cofka w dół ≥ X pips -> BUY  STOP na szczycie|
//|   Dodano: limit maks. spreadu + strażnik oczekujących            |
//+------------------------------------------------------------------+
#property strict
#include <Trade/Trade.mqh>
CTrade trade;

//=========================== Parametry =============================//
input ENUM_MA_METHOD InpMaMethod        = MODE_SMA; // EMA/SMA/SMMA/LWMA
input int            InpFastPeriod      = 10;        // szybka MA
input int            InpSlowPeriod      = 100;       // wolna MA
input int            InpPullbackPips    = 300;        // min cofka (pipsy)
input double         InpLots            = 0.10;     // wolumen
input int            InpSL_Pips         = 400;        // SL (pipsy; 0 = brak)
input int            InpTP_Pips         = 200;        // TP (pipsy; 0 = brak)
input double         InpBreakLowPips    = -200;      // przebicie Low dla SELL STOP
input double         InpBreakHighPips   = -200;      // przebicie High dla BUY  STOP
input int            InpExpireMinutes   = 25;      // wygaśnięcie oczekujących (0=GTC)
input long           InpMagic           = 20250810; // magic
input int            InpSlippagePts     = 10;       // maks. odchylenie (punkty)
input bool           InpOnePosPerCross  = false;     // jedna pozycja na przecięcie
input int            InpSwingLookback   = 15;       // ile ostatnich świec do wyznaczenia high/low
input bool InpUsePullbackFilter = true; // używać filtra cofki (true/false)

// --- Nowe: kontrola spreadu ---
input double         InpMaxSpreadPips   = 12.0;      // maks. spread (pipsy; 0 = brak limitu)
input bool           InpGuardPendingsBySpread = true; // usuń oczekujące gdy spread > limit

// tryb kierunku
enum DirectionMode { SELL_ONLY=0, BUY_ONLY=1, BOTH=2 };
input DirectionMode  InpDirection       = BOTH;     // które kierunki aktywne

//=========================== Zmienne stanu =========================//
int      fastHandle=-1, slowHandle=-1;

// czasy potwierdzonych przecięć
datetime lastCrossDownTime=0;
datetime lastCrossUpTime=0;

// SELL stan
bool     sellArmed=false;         // po cross-down: szukamy cofki w górę
double   swingLow=0.0;            // dołek poprzedzający cofkę
bool     pullbackSeenSell=false;  // cofka ≥ X pips dla SELL?
ulong    pendingSellTicket=0;     // ticket SELL STOP
bool     tradedThisCrossDown=false; // JEDNA pozycja dla danego cross-down

// BUY stan
bool     buyArmed=false;          // po cross-up: szukamy cofki w dół
double   swingHigh=0.0;           // szczyt poprzedzający cofkę
bool     pullbackSeenBuy=false;   // cofka ≥ X pips dla BUY?
ulong    pendingBuyTicket=0;      // ticket BUY STOP
bool     tradedThisCrossUp=false; // JEDNA pozycja dla danego cross-up

//=========================== Pomocnicze ============================//
double Pip(){ return (_Digits==3 || _Digits==5) ? 10.0*_Point : _Point; }
double N(double p){ return NormalizeDouble(p,_Digits); }
double SpreadPips()
{
   double b=SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double a=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   return (a-b)/Pip();
}

bool SpreadOK()
{
   if(InpMaxSpreadPips<=0.0) return true;
   double sp = SpreadPips();
   if(sp <= InpMaxSpreadPips) return true;
   PrintFormat("Spread %.1f pips > limit %.1f pips — wstrzymuję działanie.",
               sp, InpMaxSpreadPips);
   return false;
}

bool PrepareMAs()
{
   if(fastHandle==-1)
      fastHandle=iMA(_Symbol,PERIOD_CURRENT,InpFastPeriod,0,InpMaMethod,PRICE_CLOSE);
   if(slowHandle==-1)
      slowHandle=iMA(_Symbol,PERIOD_CURRENT,InpSlowPeriod,0,InpMaMethod,PRICE_CLOSE);
   return (fastHandle!=INVALID_HANDLE && slowHandle!=INVALID_HANDLE);
}

bool ReadMA(int shift,double &f,double &s)
{
   if(!PrepareMAs()) return false;
   double fb[3], sb[3];
   if(CopyBuffer(fastHandle,0,shift,3,fb)<3) return false;
   if(CopyBuffer(slowHandle,0,shift,3,sb)<3) return false;
   f=fb[0]; s=sb[0]; return true;
}

bool CrossDownConfirmed(datetime &barTime)
{
   double f2,s2,f1,s1;
   if(!ReadMA(2,f2,s2) || !ReadMA(1,f1,s1)) return false;
   if(f2> s2 && f1< s1)
   {
      MqlRates r[]; if(CopyRates(_Symbol,PERIOD_CURRENT,1,1,r)==1){ barTime=r[0].time; return true; }
   }
   return false;
}

bool CrossUpConfirmed(datetime &barTime)
{
   double f2,s2,f1,s1;
   if(!ReadMA(2,f2,s2) || !ReadMA(1,f1,s1)) return false;
   if(f2< s2 && f1> s1)
   {
      MqlRates r[]; if(CopyRates(_Symbol,PERIOD_CURRENT,1,1,r)==1){ barTime=r[0].time; return true; }
   }
   return false;
}

void ResetAllState(bool keepCrossTimes=false)
{
   // SELL
   sellArmed=false; swingLow=0.0; pullbackSeenSell=false; pendingSellTicket=0;
   if(!keepCrossTimes) lastCrossDownTime=0;
   tradedThisCrossDown=false;

   // BUY
   buyArmed=false; swingHigh=0.0; pullbackSeenBuy=false; pendingBuyTicket=0;
   if(!keepCrossTimes) lastCrossUpTime=0;
   tradedThisCrossUp=false;
}

void CancelOurPendings()
{
   for(int i=OrdersTotal()-1;i>=0;--i)
   {
      ulong t=OrderGetTicket(i); if(!t) continue;
      if(!OrderSelect(t)) continue;
      if(OrderGetInteger(ORDER_MAGIC)!=InpMagic) continue;

      ENUM_ORDER_TYPE typ=(ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
      if(typ==ORDER_TYPE_SELL_STOP || typ==ORDER_TYPE_BUY_STOP)
         trade.OrderDelete(t);
   }
   pendingSellTicket=0;
   pendingBuyTicket=0;
}

//---------------------- Składanie SELL STOP ------------------------//
bool PlaceSellStopAtSwingLow()
{
   if(InpOnePosPerCross && tradedThisCrossDown) return false;

   // kontrola spreadu przed złożeniem
   if(!SpreadOK()) return false;

   double pp=Pip();
   double price = N(swingLow - InpBreakLowPips*pp);
   double sl=0.0, tp=0.0;
   if(InpSL_Pips>0) sl=N(price + InpSL_Pips*pp);
   if(InpTP_Pips>0) tp=N(price - InpTP_Pips*pp);
   datetime exp=(InpExpireMinutes>0)?(TimeCurrent()+InpExpireMinutes*60):0;

   trade.SetExpertMagicNumber(InpMagic);
   trade.SetDeviationInPoints(InpSlippagePts);

   bool ok=trade.SellStop(InpLots,price,_Symbol,sl,tp,(exp>0?ORDER_TIME_SPECIFIED:ORDER_TIME_GTC),exp);
   if(ok){
      pendingSellTicket=trade.ResultOrder();
      PrintFormat("SELL STOP ok: price=%.5f sl=%.5f tp=%.5f (swingLow=%.5f)",
                  price,sl,tp,swingLow);
   }else{
      PrintFormat("SELL STOP błąd: ret=%d (%s)", (int)trade.ResultRetcode(),
                  trade.ResultRetcodeDescription());
   }
   return ok;
}

//---------------------- Składanie BUY STOP -------------------------//
bool PlaceBuyStopAtSwingHigh()
{
   if(InpOnePosPerCross && tradedThisCrossUp) return false;

   // kontrola spreadu przed złożeniem
   if(!SpreadOK()) return false;

   double pp=Pip();
   double price = N(swingHigh + InpBreakHighPips*pp);
   double sl=0.0, tp=0.0;
   if(InpSL_Pips>0) sl=N(price - InpSL_Pips*pp);
   if(InpTP_Pips>0) tp=N(price + InpTP_Pips*pp);
   datetime exp=(InpExpireMinutes>0)?(TimeCurrent()+InpExpireMinutes*60):0;

   trade.SetExpertMagicNumber(InpMagic);
   trade.SetDeviationInPoints(InpSlippagePts);

   bool ok=trade.BuyStop(InpLots,price,_Symbol,sl,tp,(exp>0?ORDER_TIME_SPECIFIED:ORDER_TIME_GTC),exp);
   if(ok){
      pendingBuyTicket=trade.ResultOrder();
      PrintFormat("BUY  STOP ok: price=%.5f sl=%.5f tp=%.5f (swingHigh=%.5f)",
                  price,sl,tp,swingHigh);
   }else{
      PrintFormat("BUY  STOP błąd: ret=%d (%s)", (int)trade.ResultRetcode(),
                  trade.ResultRetcodeDescription());
   }
   return ok;
}
//---------------------- Najniższy Low z ostatnich N świec ---------//
double LowestLow(int barsBack)
{
   if(barsBack <= 0) return 0.0;

   MqlRates r[];
   int copied = CopyRates(_Symbol, PERIOD_CURRENT, 1, barsBack, r); // od świecy 1 (zamknięta)
   if(copied <= 0) return 0.0;

   double low = r[0].low;
   for(int i = 1; i < copied; i++)
   {
      if(r[i].low < low)
         low = r[i].low;
   }
   return low;
}

//---------------------- Najwyższy High z ostatnich N świec --------//
double HighestHigh(int barsBack)
{
   if(barsBack <= 0) return 0.0;

   MqlRates r[];
   int copied = CopyRates(_Symbol, PERIOD_CURRENT, 1, barsBack, r);
   if(copied <= 0) return 0.0;

   double high = r[0].high;
   for(int i = 1; i < copied; i++)
   {
      if(r[i].high > high)
         high = r[i].high;
   }
   return high;
}

//=============================== OnInit ============================//
int OnInit(){ ResetAllState(); return(INIT_SUCCEEDED); }

void OnTick()
{
    if(!PrepareMAs())
        return;

    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double pp  = Pip();

    //=====================================================
    // 0) Kontrola spreadu
    //=====================================================
    if(InpMaxSpreadPips > 0.0 && InpGuardPendingsBySpread)
    {
        double sp = SpreadPips();
        if(sp > InpMaxSpreadPips)
        {
            if(pendingSellTicket != 0)
            {
                trade.OrderDelete(pendingSellTicket);
                pendingSellTicket = 0;
            }
            if(pendingBuyTicket != 0)
            {
                trade.OrderDelete(pendingBuyTicket);
                pendingBuyTicket = 0;
            }
        }
    }

    //=====================================================
    // 1) Nowe przecięcia MA
    //=====================================================
    datetime ctDown = 0, ctUp = 0;

    // CROSS DOWN
    if(CrossDownConfirmed(ctDown) && ctDown != lastCrossDownTime)
    {
        CancelOurPendings();
        ResetAllState(true);

        lastCrossDownTime = ctDown;
        if(InpDirection != BUY_ONLY)
            sellArmed = true;
    }

    // CROSS UP
    if(CrossUpConfirmed(ctUp) && ctUp != lastCrossUpTime)
    {
        CancelOurPendings();
        ResetAllState(true);

        lastCrossUpTime = ctUp;
        if(InpDirection != SELL_ONLY)
            buyArmed = true;
    }

    //=====================================================
    // 2) Pobranie aktualnej wolnej MA
    //=====================================================
    double f0, s0;
    if(!ReadMA(0, f0, s0))
        return;

    double slowMA = s0;

    //=====================================================
    // 3) SELL — wejście po powrocie ceny do slowMA
    //=====================================================
    if(sellArmed && !(InpOnePosPerCross && tradedThisCrossDown))
    {
        // nie mamy zlecenia → czekamy na powrót ask >= slowMA
        if(pendingSellTicket == 0)
        {
            if(ask >= slowMA)
            {
                int lookback = (InpSwingLookback > 0 ? InpSwingLookback : 15);
                double lowN = LowestLow(lookback);

                if(lowN > 0.0)
                {
                    swingLow = lowN;
                    double pullbackPips = (slowMA - swingLow) / pp;

                    bool okToPlace = true;

                    if(InpUsePullbackFilter)
                    {
                        if(pullbackPips < InpPullbackPips)
                        {
                            PrintFormat("SELL: cofka %.1f pips < %.1f pips — brak zlecenia.",
                                        pullbackPips, (double)InpPullbackPips);
                            okToPlace = false;
                        }
                    }

                    if(okToPlace)
                    {
                        PrintFormat("SELL: powrót do MA=%.5f, LOW(%d)=%.5f, cofka=%.1f pips → ustawiam SELL STOP",
                                    slowMA, lookback, swingLow, pullbackPips);
                        PlaceSellStopAtSwingLow();
                    }
                }
            }
        }
        else
        {
            // zlecenie oczekujące zniknęło → reset
            if(!OrderSelect(pendingSellTicket))
            {
                pendingSellTicket = 0;
            }
        }
    }

    //=====================================================
    // 4) BUY — wejście po powrocie ceny do slowMA
    //=====================================================
    if(buyArmed && !(InpOnePosPerCross && tradedThisCrossUp))
    {
        // brak zlecenia → czekamy aż bid <= slowMA
        if(pendingBuyTicket == 0)
        {
            if(bid <= slowMA)
            {
                int lookback = (InpSwingLookback > 0 ? InpSwingLookback : 15);
                double highN = HighestHigh(lookback);

                if(highN > 0.0)
                {
                    swingHigh = highN;
                    double pullbackPips = (swingHigh - slowMA) / pp;

                    bool okToPlace = true;

                    if(InpUsePullbackFilter)
                    {
                        if(pullbackPips < InpPullbackPips)
                        {
                            PrintFormat("BUY : cofka %.1f pips < %.1f pips — brak zlecenia.",
                                        pullbackPips, (double)InpPullbackPips);
                            okToPlace = false;
                        }
                    }

                    if(okToPlace)
                    {
                        PrintFormat("BUY : powrót do MA=%.5f, HIGH(%d)=%.5f, cofka=%.1f pips → ustawiam BUY STOP",
                                    slowMA, lookback, swingHigh, pullbackPips);
                        PlaceBuyStopAtSwingHigh();
                    }
                }
            }
        }
        else
        {
            if(!OrderSelect(pendingBuyTicket))
            {
                pendingBuyTicket = 0;
            }
        }
    }
}

//=========================== OnTradeTransaction ====================//
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   if(!InpOnePosPerCross) return;

   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
   {
      ulong deal = trans.deal;
      if(deal==0) return;
      if(!HistoryDealSelect(deal)) return;

      string sym   = HistoryDealGetString(deal, DEAL_SYMBOL);
      long   dtype = (long)HistoryDealGetInteger(deal, DEAL_TYPE);
      long   dmag  = (long)HistoryDealGetInteger(deal, DEAL_MAGIC);

      if(sym==_Symbol && dmag==InpMagic)
      {
         if(dtype==DEAL_TYPE_SELL)
         {
            tradedThisCrossDown = true;
            sellArmed = false;
            CancelOurPendings();
            Print("SELL otwarty -> blokuję dalsze wejścia do kolejnego cross-down.");
         }
         else if(dtype==DEAL_TYPE_BUY)
         {
            tradedThisCrossUp = true;
            buyArmed = false;
            CancelOurPendings();
            Print("BUY otwarty -> blokuję dalsze wejścia do kolejnego cross-up.");
         }
      }
   }
}

//=============================== OnDeinit ===========================//
void OnDeinit(const int reason){ /* nic */ }

