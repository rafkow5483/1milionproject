//+------------------------------------------------------------------+
//|   MA_Pullback_BuySellStop_OnePerCross.mq5                        |
//|   BUY = lustrzane odbicie SELL                                   |
//|   SELL: cross-down, cofka w gÃ³rÄ™ â‰¥ X pips -> SELL STOP na doÅ‚ku  |
//|   BUY : cross-up,   cofka w dÃ³Å‚ â‰¥ X pips -> BUY  STOP na szczycie|
//|   Dodano: limit maks. spreadu + straÅ¼nik oczekujÄ…cych            |
//+------------------------------------------------------------------+
#property strict
#include <Trade/Trade.mqh>
CTrade trade;

//=========================== Parametry =============================//
input ENUM_MA_METHOD InpMaMethod        = MODE_SMA; // EMA/SMA/SMMA/LWMA
input int            InpFastPeriod      = 2;        // szybka MA
input int            InpSlowPeriod      = 10;       // wolna MA
input int            InpPullbackPips    = 100;        // min cofka (pipsy)
input double         InpLots            = 0.10;     // wolumen
input int            InpSL_Pips         = 200;        // SL (pipsy; 0 = brak)
input int            InpTP_Pips         = 100;        // TP (pipsy; 0 = brak)
input double         InpBreakLowPips    = -100;      // przebicie Low dla SELL STOP
input double         InpBreakHighPips   = -100;      // przebicie High dla BUY  STOP
input int            InpExpireMinutes   = 6;      // wygaÅ›niÄ™cie oczekujÄ…cych (0=GTC)
input long           InpMagic           = 20250810; // magic
input int            InpSlippagePts     = 12;       // maks. odchylenie (punkty)
input bool           InpOnePosPerCross  = false;     // jedna pozycja na przeciÄ™cie
input int            InpSwingLookback   = 5;       // ile ostatnich Å›wiec do wyznaczenia high/low
input bool InpUsePullbackFilter = true; // uÅ¼ywaÄ‡ filtra cofki (true/false)

// --- Nowe: kontrola spreadu ---
input double         InpMaxSpreadPips   = 12.0;      // maks. spread (pipsy; 0 = brak limitu)
input bool           InpGuardPendingsBySpread = true; // usuÅ„ oczekujÄ…ce gdy spread > limit

// tryb kierunku
enum DirectionMode { SELL_ONLY=0, BUY_ONLY=1, BOTH=2 };
input DirectionMode  InpDirection       = BOTH;     // ktÃ³re kierunki aktywne

//=========================== Zmienne stanu =========================//
int      fastHandle=-1, slowHandle=-1;

// czasy potwierdzonych przeciÄ™Ä‡
datetime lastCrossDownTime=0;
datetime lastCrossUpTime=0;

// SELL stan
bool     sellArmed=false;         // po cross-down: szukamy cofki w gÃ³rÄ™
double   swingLow=0.0;            // doÅ‚ek poprzedzajÄ…cy cofkÄ™
bool     pullbackSeenSell=false;  // cofka â‰¥ X pips dla SELL?
ulong    pendingSellTicket=0;     // ticket SELL STOP
bool     tradedThisCrossDown=false; // JEDNA pozycja dla danego cross-down

// BUY stan
bool     buyArmed=false;          // po cross-up: szukamy cofki w dÃ³Å‚
double   swingHigh=0.0;           // szczyt poprzedzajÄ…cy cofkÄ™
bool     pullbackSeenBuy=false;   // cofka â‰¥ X pips dla BUY?
ulong    pendingBuyTicket=0;      // ticket BUY STOP
bool     tradedThisCrossUp=false; // JEDNA pozycja dla danego cross-up

//=========================== Pomocnicze ============================//
double Pip(){ return (_Digits==3 || _Digits==5) ? 10.0*_Point : _Point; }
double N(double p){ return NormalizeDouble(p,_Digits); }
double SpreadPips()
{
   double b=SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double a=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   return (a-b)/Pip();
}

bool SpreadOK()
{
   if(InpMaxSpreadPips<=0.0) return true;
   double sp = SpreadPips();
   if(sp <= InpMaxSpreadPips) return true;
   PrintFormat("Spread %.1f pips > limit %.1f pips â€” wstrzymujÄ™ dziaÅ‚anie.",
               sp, InpMaxSpreadPips);
   return false;
}

bool PrepareMAs()
{
   if(fastHandle==-1)
      fastHandle=iMA(_Symbol,PERIOD_CURRENT,InpFastPeriod,0,InpMaMethod,PRICE_CLOSE);
   if(slowHandle==-1)
      slowHandle=iMA(_Symbol,PERIOD_CURRENT,InpSlowPeriod,0,InpMaMethod,PRICE_CLOSE);
   return (fastHandle!=INVALID_HANDLE && slowHandle!=INVALID_HANDLE);
}

bool ReadMA(int shift,double &f,double &s)
{
   if(!PrepareMAs()) return false;
   double fb[3], sb[3];
   if(CopyBuffer(fastHandle,0,shift,3,fb)<3) return false;
   if(CopyBuffer(slowHandle,0,shift,3,sb)<3) return false;
   f=fb[0]; s=sb[0]; return true;
}

bool CrossDownConfirmed(datetime &barTime)
{
   double f2,s2,f1,s1;
   if(!ReadMA(2,f2,s2) || !ReadMA(1,f1,s1)) return false;
   if(f2> s2 && f1< s1)
   {
      MqlRates r[]; if(CopyRates(_Symbol,PERIOD_CURRENT,1,1,r)==1){ barTime=r[0].time; return true; }
   }
   return false;
}

bool CrossUpConfirmed(datetime &barTime)
{
   double f2,s2,f1,s1;
   if(!ReadMA(2,f2,s2) || !ReadMA(1,f1,s1)) return false;
   if(f2< s2 && f1> s1)
   {
      MqlRates r[]; if(CopyRates(_Symbol,PERIOD_CURRENT,1,1,r)==1){ barTime=r[0].time; return true; }
   }
   return false;
}

void ResetAllState(bool keepCrossTimes=false)
{
   // SELL
   sellArmed=false; swingLow=0.0; pullbackSeenSell=false; pendingSellTicket=0;
   if(!keepCrossTimes) lastCrossDownTime=0;
   tradedThisCrossDown=false;

   // BUY
   buyArmed=false; swingHigh=0.0; pullbackSeenBuy=false; pendingBuyTicket=0;
   if(!keepCrossTimes) lastCrossUpTime=0;
   tradedThisCrossUp=false;
}

void CancelOurPendings()
{
   for(int i=OrdersTotal()-1;i>=0;--i)
   {
      ulong t=OrderGetTicket(i); if(!t) continue;
      if(!OrderSelect(t)) continue;
      if(OrderGetInteger(ORDER_MAGIC)!=InpMagic) continue;

      ENUM_ORDER_TYPE typ=(ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
      if(typ==ORDER_TYPE_SELL_STOP || typ==ORDER_TYPE_BUY_STOP)
         trade.OrderDelete(t);
   }
   pendingSellTicket=0;
   pendingBuyTicket=0;
}

//---------------------- SkÅ‚adanie SELL STOP ------------------------//
bool PlaceSellStopAtSwingLow()
{
   if(InpOnePosPerCross && tradedThisCrossDown) return false;

   // kontrola spreadu przed zÅ‚oÅ¼eniem
   if(!SpreadOK()) return false;

   double pp=Pip();
   double price = N(swingLow - InpBreakLowPips*pp);
   double sl=0.0, tp=0.0;
   if(InpSL_Pips>0) sl=N(price + InpSL_Pips*pp);
   if(InpTP_Pips>0) tp=N(price - InpTP_Pips*pp);
   datetime exp=(InpExpireMinutes>0)?(TimeCurrent()+InpExpireMinutes*60):0;

   trade.SetExpertMagicNumber(InpMagic);
   trade.SetDeviationInPoints(InpSlippagePts);

   bool ok=trade.SellStop(InpLots,price,_Symbol,sl,tp,(exp>0?ORDER_TIME_SPECIFIED:ORDER_TIME_GTC),exp);
   if(ok){
      pendingSellTicket=trade.ResultOrder();
      PrintFormat("SELL STOP ok: price=%.5f sl=%.5f tp=%.5f (swingLow=%.5f)",
                  price,sl,tp,swingLow);
   }else{
      PrintFormat("SELL STOP bÅ‚Ä…d: ret=%d (%s)", (int)trade.ResultRetcode(),
                  trade.ResultRetcodeDescription());
   }
   return ok;
}

//---------------------- SkÅ‚adanie BUY STOP -------------------------//
bool PlaceBuyStopAtSwingHigh()
{
   if(InpOnePosPerCross && tradedThisCrossUp) return false;

   // kontrola spreadu przed zÅ‚oÅ¼eniem
   if(!SpreadOK()) return false;

   double pp=Pip();
   double price = N(swingHigh + InpBreakHighPips*pp);
   double sl=0.0, tp=0.0;
   if(InpSL_Pips>0) sl=N(price - InpSL_Pips*pp);
   if(InpTP_Pips>0) tp=N(price + InpTP_Pips*pp);
   datetime exp=(InpExpireMinutes>0)?(TimeCurrent()+InpExpireMinutes*60):0;

   trade.SetExpertMagicNumber(InpMagic);
   trade.SetDeviationInPoints(InpSlippagePts);

   bool ok=trade.BuyStop(InpLots,price,_Symbol,sl,tp,(exp>0?ORDER_TIME_SPECIFIED:ORDER_TIME_GTC),exp);
   if(ok){
      pendingBuyTicket=trade.ResultOrder();
      PrintFormat("BUY  STOP ok: price=%.5f sl=%.5f tp=%.5f (swingHigh=%.5f)",
                  price,sl,tp,swingHigh);
   }else{
      PrintFormat("BUY  STOP bÅ‚Ä…d: ret=%d (%s)", (int)trade.ResultRetcode(),
                  trade.ResultRetcodeDescription());
   }
   return ok;
}
//---------------------- NajniÅ¼szy Low z ostatnich N Å›wiec ---------//
double LowestLow(int barsBack)
{
   if(barsBack <= 0) return 0.0;

   MqlRates r[];
   int copied = CopyRates(_Symbol, PERIOD_CURRENT, 1, barsBack, r); // od Å›wiecy 1 (zamkniÄ™ta)
   if(copied <= 0) return 0.0;

   double low = r[0].low;
   for(int i = 1; i < copied; i++)
   {
      if(r[i].low < low)
         low = r[i].low;
   }
   return low;
}

//---------------------- NajwyÅ¼szy High z ostatnich N Å›wiec --------//
double HighestHigh(int barsBack)
{
   if(barsBack <= 0) return 0.0;

   MqlRates r[];
   int copied = CopyRates(_Symbol, PERIOD_CURRENT, 1, barsBack, r);
   if(copied <= 0) return 0.0;

   double high = r[0].high;
   for(int i = 1; i < copied; i++)
   {
      if(r[i].high > high)
         high = r[i].high;
   }
   return high;
}
//---------------------- NajniÅ¼sze CLOSE z ostatnich N Å›wiec ---------//
double LowestClose(int barsBack)
{
   if(barsBack <= 0) return 0.0;

   MqlRates r[];
   int copied = CopyRates(_Symbol, PERIOD_CURRENT, 1, barsBack, r); // od Å›wiecy 1 (zamkniÄ™ta)
   if(copied <= 0) return 0.0;

   double price = r[0].close;
   for(int i = 1; i < copied; i++)
   {
      if(r[i].close < price)
         price = r[i].close;
   }
   return price;
}

//---------------------- NajwyÅ¼sze CLOSE z ostatnich N Å›wiec --------//
double HighestClose(int barsBack)
{
   if(barsBack <= 0) return 0.0;

   MqlRates r[];
   int copied = CopyRates(_Symbol, PERIOD_CURRENT, 1, barsBack, r);
   if(copied <= 0) return 0.0;

   double price = r[0].close;
   for(int i = 1; i < copied; i++)
   {
      if(r[i].close > price)
         price = r[i].close;
   }
   return price;
}

//=============================== OnInit ============================//
int OnInit(){ ResetAllState(); return(INIT_SUCCEEDED); }

void OnTick()
{
    //-----------------------------------------------------
    // 0) Kontrola czasu handlu
    //-----------------------------------------------------
    bool time_ok = IsTimeToTrade();

    if(!time_ok)
    {
        if(pendingSellTicket != 0 || pendingBuyTicket != 0)
        {
            Print("Poza czasem handlu â€“ kasujÄ™ wszystkie pendingi:");
            CancelOurPendings();
            pendingSellTicket = 0;
            pendingBuyTicket  = 0;
            pullbackSeenBuy   = false;
            pullbackSeenSell  = false;
        }
        return;
    }

    //-----------------------------------------------------
    // 1) Przygotowanie MA
    //-----------------------------------------------------
    if(!PrepareMAs())
        return;

    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double pp  = Pip();

    //-----------------------------------------------------
    // 2) Kontrola spreadu + kasowanie pendingÃ³w
    //-----------------------------------------------------
    if(InpMaxSpreadPips > 0.0 && InpGuardPendingsBySpread)
    {
        double sp = SpreadPips();
        if(sp > InpMaxSpreadPips)
        {
            PrintFormat("Spread %.1f > %.1f â†’ kasujÄ™ pendingi.", sp, InpMaxSpreadPips);

            CancelOurPendings();
            pendingSellTicket = 0;
            pendingBuyTicket  = 0;
            pullbackSeenBuy   = false;
            pullbackSeenSell  = false;
        }
    }

    //-----------------------------------------------------
    // 2b) Wykrywanie automatycznie wygasÅ‚ych pendingÃ³w
    //-----------------------------------------------------
    if(pendingSellTicket != 0)
    {
        if(!OrderSelect(pendingSellTicket))  // MT5 skasowaÅ‚ pending (expiration)
        {
            Print("SELL STOP wygasÅ‚ â†’ reset.");
            pendingSellTicket = 0;
            pullbackSeenSell  = false;
        }
    }

    if(pendingBuyTicket != 0)
    {
        if(!OrderSelect(pendingBuyTicket))  // MT5 skasowaÅ‚ pending (expiration)
        {
            Print("BUY STOP wygasÅ‚ â†’ reset.");
            pendingBuyTicket = 0;
            pullbackSeenBuy  = false;
        }
    }

    //-----------------------------------------------------
    // 3) Sprawdzenie przeciÄ™Ä‡ MA
    //-----------------------------------------------------
    datetime ctDown = 0, ctUp = 0;

    // ---- CROSS DOWN ----
    if(CrossDownConfirmed(ctDown) && ctDown != lastCrossDownTime)
    {
        // ðŸ”¥ Natychmiast usuÅ„ wszystko
        CancelOurPendings();
        pendingSellTicket = 0;
        pendingBuyTicket  = 0;
        pullbackSeenSell  = false;
        pullbackSeenBuy   = false;

        ResetAllState(true);

        lastCrossDownTime = ctDown;

        if(InpDirection != BUY_ONLY)
            sellArmed = true;

        Print("CROSS DOWN â€“ aktywujÄ™ SELL MODE (wszystkie pendingi anulowane).");
    }

    // ---- CROSS UP ----
    if(CrossUpConfirmed(ctUp) && ctUp != lastCrossUpTime)
    {
        // ðŸ”¥ Natychmiast usuÅ„ wszystko
        CancelOurPendings();
        pendingSellTicket = 0;
        pendingBuyTicket  = 0;
        pullbackSeenSell  = false;
        pullbackSeenBuy   = false;

        ResetAllState(true);

        lastCrossUpTime = ctUp;

        if(InpDirection != SELL_ONLY)
            buyArmed = true;

        Print("CROSS UP â€“ aktywujÄ™ BUY MODE (wszystkie pendingi anulowane).");
    }

    //-----------------------------------------------------
    // 4) Aktualna slow MA
    //-----------------------------------------------------
    double f0, s0;
    if(!ReadMA(0, f0, s0))
        return;

    double slowMA = s0;

    //-----------------------------------------------------
    // 5) SELL â€“ wejÅ›cie po cofce do MA
    //-----------------------------------------------------
    if(sellArmed && !(InpOnePosPerCross && tradedThisCrossDown))
    {
        if(pendingSellTicket == 0)
        {
            if(ask >= slowMA)
            {
                int lookback = (InpSwingLookback > 0 ? InpSwingLookback : 15);
                double lowN  = LowestClose(lookback);

                if(lowN > 0.0)
                {
                    swingLow = lowN;

                    double pullbackPips = (slowMA - swingLow) / pp;

                    bool okToPlace = true;

                    if(InpUsePullbackFilter)
                    {
                        if(pullbackPips < InpPullbackPips)
                        {
                            PrintFormat("SELL: cofka %.1f < %.1f â†’ brak zlecenia.",
                                        pullbackPips, (double)InpPullbackPips);
                            okToPlace = false;
                        }
                    }

                    if(okToPlace)
                    {
                        PrintFormat("SELL: powrÃ³t do MA=%.5f, swingLow=%.5f, cofka=%.1f â†’ SELL STOP",
                                    slowMA, swingLow, pullbackPips);

                        PlaceSellStopAtSwingLow();
                    }
                }
            }
        }
        else
        {
            if(!OrderSelect(pendingSellTicket))
                pendingSellTicket = 0;
        }
    }

    //-----------------------------------------------------
    // 6) BUY â€“ wejÅ›cie po cofce do MA
    //-----------------------------------------------------
    if(buyArmed && !(InpOnePosPerCross && tradedThisCrossUp))
    {
        if(pendingBuyTicket == 0)
        {
            if(bid <= slowMA)
            {
                int lookback = (InpSwingLookback > 0 ? InpSwingLookback : 15);
                double highN = HighestClose(lookback);

                if(highN > 0.0)
                {
                    swingHigh = highN;

                    double pullbackPips = (swingHigh - slowMA) / pp;

                    bool okToPlace = true;

                    if(InpUsePullbackFilter)
                    {
                        if(pullbackPips < InpPullbackPips)
                        {
                            PrintFormat("BUY: cofka %.1f < %.1f â†’ brak zlecenia.",
                                        pullbackPips, (double)InpPullbackPips);
                            okToPlace = false;
                        }
                    }

                    if(okToPlace)
                    {
                        PrintFormat("BUY: powrÃ³t do MA=%.5f, swingHigh=%.5f, cofka=%.1f â†’ BUY STOP",
                                    slowMA, swingHigh, pullbackPips);

                        PlaceBuyStopAtSwingHigh();
                    }
                }
            }
        }
        else
        {
            if(!OrderSelect(pendingBuyTicket))
                pendingBuyTicket = 0;
        }
    }
}


//=============================== OnDeinit ===========================//
void OnDeinit(const int reason){ /* nic */ }

input bool enableTimePeriod1 = true; // DomyÅ›lnie wÅ‚Ä…czone
input bool enableTimePeriod2 = true; // DomyÅ›lnie wÅ‚Ä…czone

// Definicja zmiennych input dla czasÃ³w startu i koÅ„ca
input int startHour1 = 6;
input int startMinute1 = 0;
input int endHour1 = 13;
input int endMinute1 = 0;

input int startHour2 = 15;
input int startMinute2 = 0;
input int endHour2 = 22;
input int endMinute2 = 0;


// Funkcja sprawdzajÄ…ca, czy obecny czas mieÅ›ci siÄ™ w okreÅ›lonym przedziale
bool IsTimeToTrade() {
    MqlDateTime time;
    TimeToStruct(TimeCurrent(), time);

    // Konwersja do minut od pÃ³Å‚nocy
    int startTime1 = startHour1 * 60 + startMinute1;
    int endTime1 = endHour1 * 60 + endMinute1;
    int startTime2 = startHour2 * 60 + startMinute2;
    int endTime2 = endHour2 * 60 + endMinute2;
    int currentTime = time.hour * 60 + time.min;

    bool inTimePeriod1 = (currentTime >= startTime1 && currentTime <= endTime1) && enableTimePeriod1;
    bool inTimePeriod2 = (currentTime >= startTime2 && currentTime <= endTime2) && enableTimePeriod2;

    // Sprawdzenie czy bieÅ¼Ä…cy czas mieÅ›ci siÄ™ w aktywnych przedziaÅ‚ach
    return inTimePeriod1 || inTimePeriod2;
}
