

#property copyright "Copyright 2022, Orchard Forex"
#property link "https://www.orchardforex.com"
#property version "1.00"


//
// Trend filter MAs
//
input int                InpTrendFastMABars         = 10;          // Trend Fast MA Bars
input ENUM_MA_METHOD     InpTrendFastMAMethod       = MODE_EMA;    // Trend Fast MA Method
input ENUM_APPLIED_PRICE InpTrendFastMAAppliedPrice = PRICE_CLOSE; // Trend Fast MA Applied Price

input int                InpTrendSlowMABars         = 100;         // Trend Slow MA Bars
input ENUM_MA_METHOD     InpTrendSlowMAMethod       = MODE_EMA;    // Trend Slow MA Method
input ENUM_APPLIED_PRICE InpTrendSlowMAAppliedPrice = PRICE_CLOSE; // Trend Slow MA Applied Price

//
//	Inputs
//
//
//	Fast MA
//
input int                InpFastMABars         = 2;          // Fast MA Bars
input ENUM_MA_METHOD     InpFastMAMethod       = MODE_EMA;    // Fast MA Method
input ENUM_APPLIED_PRICE InpFastMAAppliedPrice = PRICE_CLOSE; // Fast MA Applied Price

//
//	Slow MA
//
input int                InpSlowMABars         = 15;          // Slow MA Bars
input ENUM_MA_METHOD     InpSlowMAMethod       = MODE_EMA;    // Slow MA Method
input ENUM_APPLIED_PRICE InpSlowMAAppliedPrice = PRICE_CLOSE; // Slow MA Applied Price
input int                InpSlowMAShift        = 0;           // Slow MA shift
input int    InpRoomLookbackBars = 15;   // Ile świec wstecz do HIGH/LOW
input double InpMinRoomPips      = 50.0; // Minimalny dystans w pipsach do szczytu/dołka
input double InpMaxSLPips = 30.0; // Maksymalny SL w pipsach (jeśli większy -> nie otwieraj)
input bool   InpEnableBreakEven     = true;   // Wlacz BE
input double InpBreakEvenTriggerPips= 20.0;   // Po ilu pipsach przesun SL na BE
input double InpBreakEvenOffsetPips = 0.0;    // BE + offset (np. 0 lub 1 pip)

input bool   InpEnableTrailingAfter = true;   // Wlacz TS dopiero po progu
input double InpTrailingStartPips   = 40.0;   // Od ilu pipsow zysku zaczyna dzialac TS

//
//	The basic expert uses fixed take profit, stop loss and order size
//
input double             InpOrderSize          = 0.01;  // Order size in lots
input double             InpTakeProfitPips     = 100.0; // Take profit in pips
input double             InpStopLossPips       = 100.0; // Stop loss in pips
input double             InpTrailingStopPips   = 20.0;  // Trailing stop pips
input int    InpStopLookbackBars = 15;   // SL z ilu świec (HIGH/LOW)
input double InpSLBufferPips      = 0.0; // Bufor pipsów (BUY pod low, SELL nad high)

//
//	Trades also have a magic number and a comment
//
input int                InpMagic              = 222222;                     // Magic number
input string             InpTradeComment       = "Example MA Cross with TS"; // Trade comment

input bool enableTimePeriod1 = true; // Domyślnie włączone
input bool enableTimePeriod2 = true; // Domyślnie włączone

// Definicja zmiennych input dla czasów startu i końca
input int startHour1 = 6;
input int startMinute1 = 0;
input int endHour1 = 13;
input int endMinute1 = 0;

input int startHour2 = 15;
input int startMinute2 = 0;
input int endHour2 = 22;
input int endMinute2 = 0;


// Funkcja sprawdzająca, czy obecny czas mieści się w określonym przedziale
bool IsTimeToTrade() {
    MqlDateTime time;
    TimeToStruct(TimeCurrent(), time);

    // Konwersja do minut od północy
    int startTime1 = startHour1 * 60 + startMinute1;
    int endTime1 = endHour1 * 60 + endMinute1;
    int startTime2 = startHour2 * 60 + startMinute2;
    int endTime2 = endHour2 * 60 + endMinute2;
    int currentTime = time.hour * 60 + time.min;

    bool inTimePeriod1 = (currentTime >= startTime1 && currentTime <= endTime1) && enableTimePeriod1;
    bool inTimePeriod2 = (currentTime >= startTime2 && currentTime <= endTime2) && enableTimePeriod2;

    // Sprawdzenie czy bieżący czas mieści się w aktywnych przedziałach
    return inTimePeriod1 || inTimePeriod2;
}




// Some global values
double                   TakeProfit;
double                   StopLoss;
double                   TrailingStop;

//
//	Pips, points conversion
//
double                   PipSize() { return ( PipSize( Symbol() ) ); }
double                   PipSize( string symbol ) {
   double point  = SymbolInfoDouble( symbol, SYMBOL_POINT );
   int    digits = ( int )SymbolInfoInteger( symbol, SYMBOL_DIGITS );
   return ( ( ( digits % 2 ) == 1 ) ? point * 10 : point );
}

double PipsToDouble( double pips ) { return ( pips * PipSize( Symbol() ) ); }
double PipsToDouble( double pips, string symbol ) { return ( pips * PipSize( symbol ) ); }

bool   IsMarketOpen() { return IsMarketOpen( Symbol(), TimeCurrent() ); }
bool   IsMarketOpen( datetime time ) { return IsMarketOpen( Symbol(), time ); }
bool   IsMarketOpen( string symbol, datetime time ) {

   static string   lastSymbol   = "";
   static bool     isOpen       = false;
   static datetime sessionStart = 0;
   static datetime sessionEnd   = 0;

   if ( lastSymbol == symbol && sessionEnd > sessionStart ) {
      if ( ( isOpen && time >= sessionStart && time <= sessionEnd ) || ( !isOpen && time > sessionStart && time < sessionEnd ) ) return isOpen;
   }

   lastSymbol = symbol;

   MqlDateTime mtime;
   TimeToStruct( time, mtime );
   datetime seconds  = mtime.hour * 3600 + mtime.min * 60 + mtime.sec;

   mtime.hour        = 0;
   mtime.min         = 0;
   mtime.sec         = 0;
   datetime dayStart = StructToTime( mtime );
   datetime dayEnd   = dayStart + 86400;

   datetime fromTime;
   datetime toTime;

   sessionStart = dayStart;
   sessionEnd   = dayEnd;

   for ( int session = 0;; session++ ) {

      if ( !SymbolInfoSessionTrade( symbol, ( ENUM_DAY_OF_WEEK )mtime.day_of_week, session, fromTime, toTime ) ) {
         sessionEnd = dayEnd;
         isOpen     = false;
         return isOpen;
      }

      if ( seconds < fromTime ) { // not inside a session
         sessionEnd = dayStart + fromTime;
         isOpen     = false;
         return isOpen;
      }

      if ( seconds > toTime ) { // maybe a later session
         sessionStart = dayStart + toTime;
         continue;
      }

      // at this point must be inside a session
      sessionStart = dayStart + fromTime;
      sessionEnd   = dayStart + toTime;
      isOpen       = true;
      return isOpen;
   }

   return false;
}

bool IsNewBar( bool first_call = false ) {

   static bool result = false;
   if ( !first_call ) return ( result );

   static datetime previous_time = 0;
   datetime        current_time  = iTime( Symbol(), Period(), 0 );
   result                        = false;
   if ( previous_time != current_time ) {
      previous_time = current_time;
      result        = true;
   }
   return ( result );
}

// Bring in the trade class to make trading easier
#include <Trade/Trade.mqh>
CTrade        Trade;
CPositionInfo Position;

// Handles and buffers for the moving averages
int           FastHandle;
double        FastBuffer[];
int           SlowHandle;
double        SlowBuffer[];
int TrendFastHandle;
double TrendFastBuffer[];

int TrendSlowHandle;
double TrendSlowBuffer[];


//
//	Initialisation
//
int OnInit() {

   TakeProfit   = PipsToDouble( InpTakeProfitPips );
   StopLoss     = PipsToDouble( InpStopLossPips );
   TrailingStop = PipsToDouble( InpTrailingStopPips );

   Trade.SetExpertMagicNumber( InpMagic );

   FastHandle = iMA( Symbol(), Period(), InpFastMABars, 0, InpFastMAMethod, InpFastMAAppliedPrice );
   ArraySetAsSeries( FastBuffer, true );

   //	I could use the shift here but I won't
   SlowHandle = iMA( Symbol(), Period(), InpSlowMABars, 0, InpSlowMAMethod, InpSlowMAAppliedPrice );
   ArraySetAsSeries( SlowBuffer, true );

   if ( FastHandle == INVALID_HANDLE || SlowHandle == INVALID_HANDLE ) {
      Print( "Error creating handles to moving averages" );
      return INIT_FAILED;
   }
TrendFastHandle = iMA(Symbol(), Period(), InpTrendFastMABars, 0, InpTrendFastMAMethod, InpTrendFastMAAppliedPrice);
ArraySetAsSeries(TrendFastBuffer, true);

TrendSlowHandle = iMA(Symbol(), Period(), InpTrendSlowMABars, 0, InpTrendSlowMAMethod, InpTrendSlowMAAppliedPrice);
ArraySetAsSeries(TrendSlowBuffer, true);

if(TrendFastHandle == INVALID_HANDLE || TrendSlowHandle == INVALID_HANDLE)
{
    Print("Error creating trend filter MA handles");
    return INIT_FAILED;
}


   // In case of starting the expert mid bar block the new bar result
   //	https://youtu.be/XHJPpvI2h50
   IsNewBar( true );

   return ( INIT_SUCCEEDED );
}

void OnDeinit( const int reason ) {
   IndicatorRelease( FastHandle );
   IndicatorRelease( SlowHandle );
}

void OnTick() {

   // This expert looks for a cross of fast ma over slow ma
   //	That can happen mid bar but if you check mid bar then
   //		the price often reverses and goes back and forth many times
   //	I prefer to wait for the bar to close
   //	That means I only need to run once per bar and I am looking
   //		at values from bar 1, not 0

   // Quick check if trading is possible
   if ( !IsTradeAllowed() ) return;
   // Also exit if the market may be closed
   //	https://youtu.be/GejPt5odJow
   if ( !IsMarketOpen() ) return;

   // I want to apply the trailing stop to every tick
   // so it goes here before the new bar test
  if(InpEnableBreakEven) ApplyBreakEven();

if ( TrailingStop > 0 )
{
   if(!InpEnableTrailingAfter || HasProfitAtLeast(InpTrailingStartPips))
      ApplyTrailingStop();
}

  if (!IsTimeToTrade()) return; // Jeśli nie, wyjdź z funkcji
   //	Next exit if this is not a new bar
   //	https://youtu.be/XHJPpvI2h50
   if ( !IsNewBar( true ) ) return;

   // Get the fast and slow ma values for bar 1 and bar 2
   if ( CopyBuffer( FastHandle, 0, 0, 3, FastBuffer ) < 3 ) {
      Print( "Insufficient results from fast MA" );
      return;
   }
   // This is where I apply the shift
   if ( CopyBuffer( SlowHandle, 0, InpSlowMAShift, 3, SlowBuffer ) < 3 ) {
      Print( "Insufficient results from slow MA" );
      return;
   }
if(CopyBuffer(TrendFastHandle, 0, 0, 3, TrendFastBuffer) < 3) return;
if(CopyBuffer(TrendSlowHandle, 0, 0, 3, TrendSlowBuffer) < 3) return;

double trendFast = TrendFastBuffer[1];
double trendSlow = TrendSlowBuffer[1];


   // --- WARUNKI PRZECIĘCIA ---
bool crossUp   = (FastBuffer[1] > SlowBuffer[1]) && !(FastBuffer[2] > SlowBuffer[2]);
bool crossDown = (FastBuffer[1] < SlowBuffer[1]) && !(FastBuffer[2] < SlowBuffer[2]);

bool trendBUY  = (trendFast > trendSlow);
bool trendSELL = (trendFast < trendSlow);


// --- SYGNAŁ BUY Z FILTREM ---
if(crossUp && trendBUY)
{
    OpenTrade(ORDER_TYPE_BUY);
}

// --- SYGNAŁ SELL Z FILTREM ---
if(crossDown && trendSELL)
{
    OpenTrade(ORDER_TYPE_SELL);
}



   //
}
bool GetHighestHigh(const int lookback, double &highest)
{
   if(Bars(Symbol(), Period()) < lookback + 5) return false;

   double highs[];
   ArraySetAsSeries(highs, true);

   int copied = CopyHigh(Symbol(), Period(), 1, lookback, highs); // od świecy 1 (zamknięte)
   if(copied < lookback) return false;

   int idx = ArrayMaximum(highs, 0, lookback);
   if(idx < 0) return false;

   highest = highs[idx];
   return true;
}
bool HasProfitAtLeast(double pipsNeeded)
{
   double ask = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
   double bid = SymbolInfoDouble(Symbol(), SYMBOL_BID);

   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket)) continue;
      if(Position.Symbol() != Symbol() || Position.Magic() != InpMagic) continue;

      double openPrice = Position.PriceOpen();
      double profitPips = 0.0;

      if(Position.PositionType() == POSITION_TYPE_BUY)
         profitPips = (bid - openPrice) / PipSize(Symbol());
      else
         profitPips = (openPrice - ask) / PipSize(Symbol());

      if(profitPips >= pipsNeeded)
         return true;
   }
   return false;
}

void ApplyBreakEven()
{
   double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
   double ask   = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
   double bid   = SymbolInfoDouble(Symbol(), SYMBOL_BID);

   double minStopDist = (double)SymbolInfoInteger(Symbol(), SYMBOL_TRADE_STOPS_LEVEL) * point;
   double offset      = PipsToDouble(InpBreakEvenOffsetPips);

   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket)) continue;
      if(Position.Symbol() != Symbol() || Position.Magic() != InpMagic) continue;

      double openPrice = Position.PriceOpen();
      double sl        = Position.StopLoss();

      double profitPips = 0.0;
      if(Position.PositionType() == POSITION_TYPE_BUY)
         profitPips = (bid - openPrice) / PipSize(Symbol());
      else
         profitPips = (openPrice - ask) / PipSize(Symbol());

      if(profitPips < InpBreakEvenTriggerPips) continue;

      double targetSL = openPrice;

      if(Position.PositionType() == POSITION_TYPE_BUY)
      {
         targetSL = openPrice + offset;
         double maxAllowed = bid - minStopDist;
         if(minStopDist > 0 && targetSL > maxAllowed) targetSL = maxAllowed;

         if(sl != 0 && sl >= targetSL) continue;
      }
      else
      {
         targetSL = openPrice - offset;
         double minAllowed = ask + minStopDist;
         if(minStopDist > 0 && targetSL < minAllowed) targetSL = minAllowed;

         if(sl != 0 && sl <= targetSL) continue;
      }

      targetSL = NormalizeDouble(targetSL, Digits());

      ResetLastError();
      if(!Trade.PositionModify(ticket, targetSL, Position.TakeProfit()))
      {
         int err = GetLastError();
         PrintFormat("BE: Failed to set SL on ticket %I64u to %f, err=%i", ticket, targetSL, err);
      }
   }
}

bool GetLowestLow(const int lookback, double &lowest)
{
   if(Bars(Symbol(), Period()) < lookback + 5) return false;

   double lows[];
   ArraySetAsSeries(lows, true);

   int copied = CopyLow(Symbol(), Period(), 1, lookback, lows); // od świecy 1 (zamknięte)
   if(copied < lookback) return false;

   int idx = ArrayMinimum(lows, 0, lookback);
   if(idx < 0) return false;

   lowest = lows[idx];
   return true;
}

bool HasRoomToOpen(const ENUM_ORDER_TYPE type)
{
   double required = PipsToDouble(InpMinRoomPips);

   if(type == ORDER_TYPE_BUY)
   {
      double highest;
      if(!GetHighestHigh(InpRoomLookbackBars, highest)) return false;

      double ask = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
      double room = highest - ask;

      return (room >= required);
   }
   else if(type == ORDER_TYPE_SELL)
   {
      double lowest;
      if(!GetLowestLow(InpRoomLookbackBars, lowest)) return false;

      double bid = SymbolInfoDouble(Symbol(), SYMBOL_BID);
      double room = bid - lowest;

      return (room >= required);
   }

   return false;
}
void OpenTrade( ENUM_ORDER_TYPE type )
{
   if(!HasRoomToOpen(type))
   {
      double required = InpMinRoomPips;

      if(type == ORDER_TYPE_BUY)
      {
         double highest;
         if(GetHighestHigh(InpRoomLookbackBars, highest))
         {
            double ask = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
            double roomPips = (highest - ask) / PipSize(Symbol());
            PrintFormat("SKIP BUY: za malo miejsca do szczytu z %d swiec. Room=%.1f pips, wymagane=%.1f",
                        InpRoomLookbackBars, roomPips, required);
         }
         else Print("SKIP BUY: brak danych do wyliczenia highest high");
      }
      else if(type == ORDER_TYPE_SELL)
      {
         double lowest;
         if(GetLowestLow(InpRoomLookbackBars, lowest))
         {
            double bid = SymbolInfoDouble(Symbol(), SYMBOL_BID);
            double roomPips = (bid - lowest) / PipSize(Symbol());
            PrintFormat("SKIP SELL: za malo miejsca do dolka z %d swiec. Room=%.1f pips, wymagane=%.1f",
                        InpRoomLookbackBars, roomPips, required);
         }
         else Print("SKIP SELL: brak danych do wyliczenia lowest low");
      }
      return;
   }

   // --- OTWARCIE ---
   double price = 0.0;
   double sl    = 0.0;
   double tp    = 0.0;

   double ask   = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
   double bid   = SymbolInfoDouble(Symbol(), SYMBOL_BID);
   double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);

   // minimalny dystans SL/TP od ceny (w punktach) wymagany przez brokera
   double minStopDist = (double)SymbolInfoInteger(Symbol(), SYMBOL_TRADE_STOPS_LEVEL) * point;

   // bufor w pipsach (np. 1-3 pips) żeby SL nie stał idealnie na ekstremum
   double slBuffer = PipsToDouble(InpSLBufferPips);

   if(type == ORDER_TYPE_BUY)
   {
      price = ask;

      // SL = najniższe LOW z ostatnich InpStopLookbackBars zamkniętych świec
      double lowest;
      if(InpStopLookbackBars <= 0 || !GetLowestLow(InpStopLookbackBars, lowest))
      {
         PrintFormat("SKIP BUY: nie moge wyliczyc LOW z %d swiec (SL dynamiczny)", InpStopLookbackBars);
         return;
      }
      sl = lowest - slBuffer;

      tp = price + TakeProfit;

      // SL nie może być za blisko ceny (broker stops level)
      double maxAllowed = bid - minStopDist; // dla BUY SL musi być <= maxAllowed
      if(minStopDist > 0 && sl > maxAllowed) sl = maxAllowed;
   }
   else // ORDER_TYPE_SELL
   {
      price = bid;

      // SL = najwyższe HIGH z ostatnich InpStopLookbackBars zamkniętych świec
      double highest;
      if(InpStopLookbackBars <= 0 || !GetHighestHigh(InpStopLookbackBars, highest))
      {
         PrintFormat("SKIP SELL: nie moge wyliczyc HIGH z %d swiec (SL dynamiczny)", InpStopLookbackBars);
         return;
      }
      sl = highest + slBuffer;

      tp = price - TakeProfit;

      // SL nie może być za blisko ceny (broker stops level)
      double minAllowed = ask + minStopDist; // dla SELL SL musi być >= minAllowed
      if(minStopDist > 0 && sl < minAllowed) sl = minAllowed;
   }

   // --- LIMIT MAKSYMALNEGO SL (W PIPSACH) ---
   double slDistPips = 0.0;
   if(type == ORDER_TYPE_BUY)
      slDistPips = (price - sl) / PipSize(Symbol());   // BUY: cena - SL
   else
      slDistPips = (sl - price) / PipSize(Symbol());   // SELL: SL - cena

   if(slDistPips > InpMaxSLPips)
   {
      PrintFormat("SKIP %s: SL za duzy (%.1f pips) > limit (%.1f pips). price=%.5f sl=%.5f",
                  (type==ORDER_TYPE_BUY ? "BUY" : "SELL"),
                  slDistPips, InpMaxSLPips, price, sl);
      return;
   }

   price = NormalizeDouble(price, Digits());
   sl    = NormalizeDouble(sl, Digits());
   tp    = NormalizeDouble(tp, Digits());

   // jeśli chcesz zachować możliwość "wyłączenia" TP przez input:
   if(InpTakeProfitPips == 0) tp = 0;

   // UWAGA: jeśli ustawisz InpStopLossPips=0 to wcześniej miałeś wyłączanie SL,
   // ale tu SL jest dynamiczny, więc tego nie robimy (żeby nie zniknął SL)

   PrintFormat("OPEN %s: price=%.5f SL=%.5f (%.1f pips) TP=%.5f lookback=%d buffer=%.1f",
               (type==ORDER_TYPE_BUY ? "BUY" : "SELL"),
               price, sl, slDistPips, tp, InpStopLookbackBars, InpSLBufferPips);

   if(!Trade.PositionOpen(Symbol(), type, InpOrderSize, price, sl, tp, InpTradeComment))
   {
      Print("Open failed for %s, %s, price=%f, sl=%f, tp=%f",
            Symbol(), EnumToString(type), price, sl, tp);
   }
}


bool IsTradeAllowed() {

   return ( ( bool )MQLInfoInteger( MQL_TRADE_ALLOWED )              // Trading allowed in input dialog
            && ( bool )TerminalInfoInteger( TERMINAL_TRADE_ALLOWED ) // Trading allowed in terminal
            && ( bool )AccountInfoInteger( ACCOUNT_TRADE_ALLOWED )   // Is account able to trade, not locked out
            && ( bool )AccountInfoInteger( ACCOUNT_TRADE_EXPERT )    // Is account able to auto trade
   );
}

//-	9.	The trailing stop function
void ApplyTrailingStop() {

   double ask                   = SymbolInfoDouble( Symbol(), SYMBOL_ASK );
   double bid                   = SymbolInfoDouble( Symbol(), SYMBOL_BID );
   double buyTrailingStopPrice  = ask - TrailingStop;
   double sellTrailingStopPrice = bid + TrailingStop;
   int    err;

   //	https://youtu.be/u9qFvriLQnU
   // For hedging accounts, not netting
   for ( int i = PositionsTotal() - 1; i >= 0; i-- ) {
      ulong ticket = PositionGetTicket( i );
      if ( !PositionSelectByTicket( ticket ) ) continue;
      if ( Position.Symbol() != Symbol() || Position.Magic() != InpMagic ) continue;

      if ( Position.PositionType() == POSITION_TYPE_BUY && buyTrailingStopPrice > Position.PriceOpen() &&
           ( Position.StopLoss() == 0 || buyTrailingStopPrice > Position.StopLoss() ) ) {
         ResetLastError();
         if ( !Trade.PositionModify( ticket, buyTrailingStopPrice, Position.TakeProfit() ) ) {
            err = GetLastError();
            PrintFormat( "Failed to update ts on ticket %I64u to %f, err=%i", ticket, buyTrailingStopPrice, err );
         }
      }

      if ( Position.PositionType() == POSITION_TYPE_SELL && sellTrailingStopPrice < Position.PriceOpen() &&
           ( Position.StopLoss() == 0 || sellTrailingStopPrice < Position.StopLoss() ) ) {
         ResetLastError();
         if ( !Trade.PositionModify( ticket, sellTrailingStopPrice, Position.TakeProfit() ) ) {
            err = GetLastError();
            PrintFormat( "Failed to update ts on ticket %I64u to %f, err=%i", ticket, sellTrailingStopPrice, err );
            }
        }
   }
}
