


#property copyright "Copyright 2022, Orchard Forex"
#property link "https://www.orchardforex.com"
#property version "1.00"


//
// Trend filter MAs
//
input int                InpTrendFastMABars         = 10;          // Trend Fast MA Bars
input ENUM_MA_METHOD     InpTrendFastMAMethod       = MODE_EMA;    // Trend Fast MA Method
input ENUM_APPLIED_PRICE InpTrendFastMAAppliedPrice = PRICE_CLOSE; // Trend Fast MA Applied Price

input int                InpTrendSlowMABars         = 25;         // Trend Slow MA Bars
input ENUM_MA_METHOD     InpTrendSlowMAMethod       = MODE_EMA;    // Trend Slow MA Method
input ENUM_APPLIED_PRICE InpTrendSlowMAAppliedPrice = PRICE_CLOSE; // Trend Slow MA Applied Price

//
//	Inputs
//
//
//	Fast MA
//
input int                InpFastMABars         = 1;          // Fast MA Bars
input ENUM_MA_METHOD     InpFastMAMethod       = MODE_EMA;    // Fast MA Method
input ENUM_APPLIED_PRICE InpFastMAAppliedPrice = PRICE_CLOSE; // Fast MA Applied Price

//
//	Slow MA
//
input int                InpSlowMABars         = 3;          // Slow MA Bars
input ENUM_MA_METHOD     InpSlowMAMethod       = MODE_EMA;    // Slow MA Method
input ENUM_APPLIED_PRICE InpSlowMAAppliedPrice = PRICE_CLOSE; // Slow MA Applied Price
input int                InpSlowMAShift        = 0;           // Slow MA shift
input int    InpRoomLookbackBars = 15;   // Ile świec wstecz do HIGH/LOW
input double InpMinRoomPips      = 300.0; // Minimalny dystans w pipsach do szczytu/dołka
input double InpMaxSLPips = 500.0; // Maksymalny SL w pipsach (jeśli większy -> nie otwieraj)

//
//	The basic expert uses fixed take profit, stop loss and order size
//
input double             InpOrderSize          = 0.01;  // Order size in lots
input double             InpTakeProfitPips     = 300.0; // Take profit in pips
input double             InpStopLossPips       = 300.0; // Stop loss in pips
input double             InpTrailingStopPips   = 500.0;  // Trailing stop pips
input int    InpStopLookbackBars = 4;   // SL z ilu świec (HIGH/LOW)
input double InpSLBufferPips      = 0.0; // Bufor pipsów (BUY pod low, SELL nad high)

//
//	Trades also have a magic number and a comment
//
input int                InpMagic              = 222222;                     // Magic number
input string             InpTradeComment       = "Example MA Cross with TS"; // Trade comment

input bool enableTimePeriod1 = true; // Domyślnie włączone
input bool enableTimePeriod2 = false; // Domyślnie włączone

// Definicja zmiennych input dla czasów startu i końca
input int startHour1 = 8;
input int startMinute1 = 0;
input int endHour1 = 12;
input int endMinute1 = 0;

input int startHour2 = 15;
input int startMinute2 = 0;
input int endHour2 = 22;
input int endMinute2 = 0;
// --- TP MODE ---
enum ENUM_TP_MODE
{
   TP_MODE_FIXED = 0,          // Stały TP (InpTakeProfitPips)
   TP_MODE_DYNAMIC_EXTREME = 1,// TP = szczyt/dołek z lookbacku (InpRoomLookbackBars)
   TP_MODE_OFF = 2             // Bez TP
};

input ENUM_TP_MODE InpTPMode        = TP_MODE_FIXED; // Tryb TP
input int          InpTpLookbackBars = 15;            // Z ilu świec brać szczyt/dołek dla TP (jeśli dynamiczny)
input double       InpTPBufferPips   = 0.0;           // Bufor pipsów od ekstremum (BUY: poniżej high, SELL: powyżej low)


// Funkcja sprawdzająca, czy obecny czas mieści się w określonym przedziale
bool IsTimeToTrade() {
    MqlDateTime time;
    TimeToStruct(TimeCurrent(), time);

    // Konwersja do minut od północy
    int startTime1 = startHour1 * 60 + startMinute1;
    int endTime1 = endHour1 * 60 + endMinute1;
    int startTime2 = startHour2 * 60 + startMinute2;
    int endTime2 = endHour2 * 60 + endMinute2;
    int currentTime = time.hour * 60 + time.min;

    bool inTimePeriod1 = (currentTime >= startTime1 && currentTime <= endTime1) && enableTimePeriod1;
    bool inTimePeriod2 = (currentTime >= startTime2 && currentTime <= endTime2) && enableTimePeriod2;

    // Sprawdzenie czy bieżący czas mieści się w aktywnych przedziałach
    return inTimePeriod1 || inTimePeriod2;
}




// Some global values
double                   TakeProfit;
double                   StopLoss;
double                   TrailingStop;

//
//	Pips, points conversion
//
double                   PipSize() { return ( PipSize( Symbol() ) ); }
double                   PipSize( string symbol ) {
   double point  = SymbolInfoDouble( symbol, SYMBOL_POINT );
   int    digits = ( int )SymbolInfoInteger( symbol, SYMBOL_DIGITS );
   return ( ( ( digits % 2 ) == 1 ) ? point * 10 : point );
}

double PipsToDouble( double pips ) { return ( pips * PipSize( Symbol() ) ); }
double PipsToDouble( double pips, string symbol ) { return ( pips * PipSize( symbol ) ); }

bool   IsMarketOpen() { return IsMarketOpen( Symbol(), TimeCurrent() ); }
bool   IsMarketOpen( datetime time ) { return IsMarketOpen( Symbol(), time ); }
bool   IsMarketOpen( string symbol, datetime time ) {

   static string   lastSymbol   = "";
   static bool     isOpen       = false;
   static datetime sessionStart = 0;
   static datetime sessionEnd   = 0;

   if ( lastSymbol == symbol && sessionEnd > sessionStart ) {
      if ( ( isOpen && time >= sessionStart && time <= sessionEnd ) || ( !isOpen && time > sessionStart && time < sessionEnd ) ) return isOpen;
   }

   lastSymbol = symbol;

   MqlDateTime mtime;
   TimeToStruct( time, mtime );
   datetime seconds  = mtime.hour * 3600 + mtime.min * 60 + mtime.sec;

   mtime.hour        = 0;
   mtime.min         = 0;
   mtime.sec         = 0;
   datetime dayStart = StructToTime( mtime );
   datetime dayEnd   = dayStart + 86400;

   datetime fromTime;
   datetime toTime;

   sessionStart = dayStart;
   sessionEnd   = dayEnd;

   for ( int session = 0;; session++ ) {

      if ( !SymbolInfoSessionTrade( symbol, ( ENUM_DAY_OF_WEEK )mtime.day_of_week, session, fromTime, toTime ) ) {
         sessionEnd = dayEnd;
         isOpen     = false;
         return isOpen;
      }

      if ( seconds < fromTime ) { // not inside a session
         sessionEnd = dayStart + fromTime;
         isOpen     = false;
         return isOpen;
      }

      if ( seconds > toTime ) { // maybe a later session
         sessionStart = dayStart + toTime;
         continue;
      }

      // at this point must be inside a session
      sessionStart = dayStart + fromTime;
      sessionEnd   = dayStart + toTime;
      isOpen       = true;
      return isOpen;
   }

   return false;
}

bool IsNewBar( bool first_call = false ) {

   static bool result = false;
   if ( !first_call ) return ( result );

   static datetime previous_time = 0;
   datetime        current_time  = iTime( Symbol(), Period(), 0 );
   result                        = false;
   if ( previous_time != current_time ) {
      previous_time = current_time;
      result        = true;
   }
   return ( result );
}

// Bring in the trade class to make trading easier
#include <Trade/Trade.mqh>
CTrade        Trade;
CPositionInfo Position;

// Handles and buffers for the moving averages
int           FastHandle;
double        FastBuffer[];
int           SlowHandle;
double        SlowBuffer[];
int TrendFastHandle;
double TrendFastBuffer[];

int TrendSlowHandle;
double TrendSlowBuffer[];


//
//	Initialisation
//
int OnInit() {

   TakeProfit   = PipsToDouble( InpTakeProfitPips );
   StopLoss     = PipsToDouble( InpStopLossPips );
   TrailingStop = PipsToDouble( InpTrailingStopPips );

   Trade.SetExpertMagicNumber( InpMagic );

   FastHandle = iMA( Symbol(), Period(), InpFastMABars, 0, InpFastMAMethod, InpFastMAAppliedPrice );
   ArraySetAsSeries( FastBuffer, true );

   //	I could use the shift here but I won't
   SlowHandle = iMA( Symbol(), Period(), InpSlowMABars, 0, InpSlowMAMethod, InpSlowMAAppliedPrice );
   ArraySetAsSeries( SlowBuffer, true );

   if ( FastHandle == INVALID_HANDLE || SlowHandle == INVALID_HANDLE ) {
      Print( "Error creating handles to moving averages" );
      return INIT_FAILED;
   }
TrendFastHandle = iMA(Symbol(), Period(), InpTrendFastMABars, 0, InpTrendFastMAMethod, InpTrendFastMAAppliedPrice);
ArraySetAsSeries(TrendFastBuffer, true);

TrendSlowHandle = iMA(Symbol(), Period(), InpTrendSlowMABars, 0, InpTrendSlowMAMethod, InpTrendSlowMAAppliedPrice);
ArraySetAsSeries(TrendSlowBuffer, true);

if(TrendFastHandle == INVALID_HANDLE || TrendSlowHandle == INVALID_HANDLE)
{
    Print("Error creating trend filter MA handles");
    return INIT_FAILED;
}


   // In case of starting the expert mid bar block the new bar result
   //	https://youtu.be/XHJPpvI2h50
   IsNewBar( true );

   return ( INIT_SUCCEEDED );
}

void OnDeinit( const int reason ) {
   IndicatorRelease( FastHandle );
   IndicatorRelease( SlowHandle );
}

void OnTick() {

   // This expert looks for a cross of fast ma over slow ma
   //	That can happen mid bar but if you check mid bar then
   //		the price often reverses and goes back and forth many times
   //	I prefer to wait for the bar to close
   //	That means I only need to run once per bar and I am looking
   //		at values from bar 1, not 0

   // Quick check if trading is possible
   if ( !IsTradeAllowed() ) return;
   // Also exit if the market may be closed
   //	https://youtu.be/GejPt5odJow
   if ( !IsMarketOpen() ) return;

   // I want to apply the trailing stop to every tick
   // so it goes here before the new bar test
   if ( TrailingStop > 0 ) ApplyTrailingStop();
  if (!IsTimeToTrade()) return; // Jeśli nie, wyjdź z funkcji
   //	Next exit if this is not a new bar
   //	https://youtu.be/XHJPpvI2h50
   if ( !IsNewBar( true ) ) return;

   // Get the fast and slow ma values for bar 1 and bar 2
   if ( CopyBuffer( FastHandle, 0, 0, 3, FastBuffer ) < 3 ) {
      Print( "Insufficient results from fast MA" );
      return;
   }
   // This is where I apply the shift
   if ( CopyBuffer( SlowHandle, 0, InpSlowMAShift, 3, SlowBuffer ) < 3 ) {
      Print( "Insufficient results from slow MA" );
      return;
   }
if(CopyBuffer(TrendFastHandle, 0, 0, 3, TrendFastBuffer) < 3) return;
if(CopyBuffer(TrendSlowHandle, 0, 0, 3, TrendSlowBuffer) < 3) return;

double trendFast = TrendFastBuffer[1];
double trendSlow = TrendSlowBuffer[1];


   // --- WARUNKI PRZECIĘCIA ---
bool crossUp   = (FastBuffer[1] > SlowBuffer[1]) && !(FastBuffer[2] > SlowBuffer[2]);
bool crossDown = (FastBuffer[1] < SlowBuffer[1]) && !(FastBuffer[2] < SlowBuffer[2]);

bool trendBUY  = (trendFast > trendSlow);
bool trendSELL = (trendFast < trendSlow);


// --- SYGNAŁ BUY Z FILTREM ---
if(crossUp && trendBUY)
{
    OpenTrade(ORDER_TYPE_BUY);
}

// --- SYGNAŁ SELL Z FILTREM ---
if(crossDown && trendSELL)
{
    OpenTrade(ORDER_TYPE_SELL);
}



   //
}
bool GetHighestHigh(const int lookback, double &highest)
{
   if(Bars(Symbol(), Period()) < lookback + 5) return false;

   double highs[];
   ArraySetAsSeries(highs, true);

   int copied = CopyHigh(Symbol(), Period(), 1, lookback, highs); // od świecy 1 (zamknięte)
   if(copied < lookback) return false;

   int idx = ArrayMaximum(highs, 0, lookback);
   if(idx < 0) return false;

   highest = highs[idx];
   return true;
}

bool GetLowestLow(const int lookback, double &lowest)
{
   if(Bars(Symbol(), Period()) < lookback + 5) return false;

   double lows[];
   ArraySetAsSeries(lows, true);

   int copied = CopyLow(Symbol(), Period(), 1, lookback, lows); // od świecy 1 (zamknięte)
   if(copied < lookback) return false;

   int idx = ArrayMinimum(lows, 0, lookback);
   if(idx < 0) return false;

   lowest = lows[idx];
   return true;
}

bool GetDynamicTPPrice(const ENUM_ORDER_TYPE type, double entryPrice, double &tpOut)
{
   double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
   double minStopDist = (double)SymbolInfoInteger(Symbol(), SYMBOL_TRADE_STOPS_LEVEL) * point;

   double tpBuffer = PipsToDouble(InpTPBufferPips);

   // lookback do TP:
    int lookback = InpRoomLookbackBars;
// <-- albo tu możesz dać InpRoomLookbackBars jeśli ma być zawsze identycznie

   if(type == ORDER_TYPE_BUY)
   {
      double highest;
      if(!GetHighestHigh(lookback, highest))
         return false;

      double tp = highest - tpBuffer;

      // TP musi być powyżej wejścia i spełniać minimalny dystans brokera
      if(tp <= entryPrice + minStopDist)
         return false;

      tpOut = tp;
      return true;
   }
   else if(type == ORDER_TYPE_SELL)
   {
      double lowest;
      if(!GetLowestLow(lookback, lowest))
         return false;

      double tp = lowest + tpBuffer;

      // TP musi być poniżej wejścia i spełniać minimalny dystans brokera
      if(tp >= entryPrice - minStopDist)
         return false;

      tpOut = tp;
      return true;
   }

   return false;
}



bool HasRoomToOpen(const ENUM_ORDER_TYPE type)
{
   double required = PipsToDouble(InpMinRoomPips);

   if(type == ORDER_TYPE_BUY)
   {
      double highest;
      if(!GetHighestHigh(InpRoomLookbackBars, highest)) return false;

      double ask = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
      double room = highest - ask;

      return (room >= required);
   }
   else if(type == ORDER_TYPE_SELL)
   {
      double lowest;
      if(!GetLowestLow(InpRoomLookbackBars, lowest)) return false;

      double bid = SymbolInfoDouble(Symbol(), SYMBOL_BID);
      double room = bid - lowest;

      return (room >= required);
   }

   return false;
}

void OpenTrade( ENUM_ORDER_TYPE type )
{
   if(!HasRoomToOpen(type))
   {
      double required = InpMinRoomPips;

      if(type == ORDER_TYPE_BUY)
      {
         double highest;
         if(GetHighestHigh(InpRoomLookbackBars, highest))
         {
            double ask = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
            double roomPips = (highest - ask) / PipSize(Symbol());
            PrintFormat("SKIP BUY: za malo miejsca do szczytu z %d swiec. Room=%.1f pips, wymagane=%.1f",
                        InpRoomLookbackBars, roomPips, required);
         }
         else Print("SKIP BUY: brak danych do wyliczenia highest high");
      }
      else if(type == ORDER_TYPE_SELL)
      {
         double lowest;
         if(GetLowestLow(InpRoomLookbackBars, lowest))
         {
            double bid = SymbolInfoDouble(Symbol(), SYMBOL_BID);
            double roomPips = (bid - lowest) / PipSize(Symbol());
            PrintFormat("SKIP SELL: za malo miejsca do dolka z %d swiec. Room=%.1f pips, wymagane=%.1f",
                        InpRoomLookbackBars, roomPips, required);
         }
         else Print("SKIP SELL: brak danych do wyliczenia lowest low");
      }
      return;
   }

   // --- OTWARCIE ---
   double price = 0.0;
   double sl    = 0.0;
   double tp    = 0.0;

   double ask   = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
   double bid   = SymbolInfoDouble(Symbol(), SYMBOL_BID);
   double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);

   // minimalny dystans SL/TP od ceny (w punktach) wymagany przez brokera
   double minStopDist = (double)SymbolInfoInteger(Symbol(), SYMBOL_TRADE_STOPS_LEVEL) * point;

   // buffer SL w pipsach
   double slBuffer = PipsToDouble(InpSLBufferPips);

   // --- SL DYNAMICZNY ---
   if(type == ORDER_TYPE_BUY)
   {
      price = ask;

      double lowest;
      if(InpStopLookbackBars <= 0 || !GetLowestLow(InpStopLookbackBars, lowest))
      {
         PrintFormat("SKIP BUY: nie moge wyliczyc LOW z %d swiec (SL dynamiczny)", InpStopLookbackBars);
         return;
      }
      sl = lowest - slBuffer;

      // SL dla BUY musi być <= bid - stopslevel
      double maxAllowed = bid - minStopDist;
      if(minStopDist > 0 && sl > maxAllowed) sl = maxAllowed;
   }
   else // SELL
   {
      price = bid;

      double highest;
      if(InpStopLookbackBars <= 0 || !GetHighestHigh(InpStopLookbackBars, highest))
      {
         PrintFormat("SKIP SELL: nie moge wyliczyc HIGH z %d swiec (SL dynamiczny)", InpStopLookbackBars);
         return;
      }
      sl = highest + slBuffer;

      // SL dla SELL musi być >= ask + stopslevel
      double minAllowed = ask + minStopDist;
      if(minStopDist > 0 && sl < minAllowed) sl = minAllowed;
   }

   // --- LIMIT MAKSYMALNEGO SL (W PIPSACH) ---
   double slDistPips = 0.0;
   if(type == ORDER_TYPE_BUY)
      slDistPips = (price - sl) / PipSize(Symbol());
   else
      slDistPips = (sl - price) / PipSize(Symbol());

   if(slDistPips > InpMaxSLPips)
   {
      PrintFormat("SKIP %s: SL za duzy (%.1f pips) > limit (%.1f pips). price=%.5f sl=%.5f",
                  (type==ORDER_TYPE_BUY ? "BUY" : "SELL"),
                  slDistPips, InpMaxSLPips, price, sl);
      return;
   }

   // --- TP (STAŁY / DYNAMICZNY / OFF) ---
   tp = 0.0;

   if(InpTPMode == TP_MODE_OFF)
   {
      tp = 0.0;
   }
   else if(InpTPMode == TP_MODE_FIXED)
   {
      if(InpTakeProfitPips > 0)
      {
         if(type == ORDER_TYPE_BUY)  tp = price + TakeProfit;
         if(type == ORDER_TYPE_SELL) tp = price - TakeProfit;
      }
      else tp = 0.0;
   }
   else if(InpTPMode == TP_MODE_DYNAMIC_EXTREME)
   {
      double tpDyn;
      if(!GetDynamicTPPrice(type, price, tpDyn))
      {
         PrintFormat("SKIP %s: nie moge wyliczyc dynamicznego TP (lookback=%d, buffer=%.1f pips) albo TP za blisko ceny",
                     (type==ORDER_TYPE_BUY ? "BUY" : "SELL"),
                     InpTpLookbackBars, InpTPBufferPips);
         return;
      }
      tp = tpDyn;
   }

   // --- WALIDACJA TP pod brokera (stops level) ---
   if(tp > 0.0 && minStopDist > 0.0)
   {
      if(type == ORDER_TYPE_BUY)
      {
         // TP dla BUY musi być >= ask + stopslevel
         double minTp = ask + minStopDist;
         if(tp < minTp) tp = minTp;
      }
      else
      {
         // TP dla SELL musi być <= bid - stopslevel
         double maxTp = bid - minStopDist;
         if(tp > maxTp) tp = maxTp;
      }
   }

   // --- NORMALIZACJA ---
   price = NormalizeDouble(price, Digits());
   sl    = NormalizeDouble(sl, Digits());
   tp    = (tp == 0.0 ? 0.0 : NormalizeDouble(tp, Digits()));

   PrintFormat("OPEN %s: price=%.5f SL=%.5f (%.1f pips) TP=%.5f | SLlookback=%d TPmode=%d TPlb=%d",
               (type==ORDER_TYPE_BUY ? "BUY" : "SELL"),
               price, sl, slDistPips, tp,
               InpStopLookbackBars, (int)InpTPMode, InpTpLookbackBars);

   if(!Trade.PositionOpen(Symbol(), type, InpOrderSize, price, sl, tp, InpTradeComment))
   {
      int err = GetLastError();
      PrintFormat("Open failed: %s %s price=%f sl=%f tp=%f err=%d",
                  Symbol(), EnumToString(type), price, sl, tp, err);
   }
}


bool IsTradeAllowed() {

   return ( ( bool )MQLInfoInteger( MQL_TRADE_ALLOWED )              // Trading allowed in input dialog
            && ( bool )TerminalInfoInteger( TERMINAL_TRADE_ALLOWED ) // Trading allowed in terminal
            && ( bool )AccountInfoInteger( ACCOUNT_TRADE_ALLOWED )   // Is account able to trade, not locked out
            && ( bool )AccountInfoInteger( ACCOUNT_TRADE_EXPERT )    // Is account able to auto trade
   );
}

//-	9.	The trailing stop function
void ApplyTrailingStop() {

   double ask                   = SymbolInfoDouble( Symbol(), SYMBOL_ASK );
   double bid                   = SymbolInfoDouble( Symbol(), SYMBOL_BID );
   double buyTrailingStopPrice  = ask - TrailingStop;
   double sellTrailingStopPrice = bid + TrailingStop;
   int    err;

   //	https://youtu.be/u9qFvriLQnU
   // For hedging accounts, not netting
   for ( int i = PositionsTotal() - 1; i >= 0; i-- ) {
      ulong ticket = PositionGetTicket( i );
      if ( !PositionSelectByTicket( ticket ) ) continue;
      if ( Position.Symbol() != Symbol() || Position.Magic() != InpMagic ) continue;

      if ( Position.PositionType() == POSITION_TYPE_BUY && buyTrailingStopPrice > Position.PriceOpen() &&
           ( Position.StopLoss() == 0 || buyTrailingStopPrice > Position.StopLoss() ) ) {
         ResetLastError();
         if ( !Trade.PositionModify( ticket, buyTrailingStopPrice, Position.TakeProfit() ) ) {
            err = GetLastError();
            PrintFormat( "Failed to update ts on ticket %I64u to %f, err=%i", ticket, buyTrailingStopPrice, err );
         }
      }

      if ( Position.PositionType() == POSITION_TYPE_SELL && sellTrailingStopPrice < Position.PriceOpen() &&
           ( Position.StopLoss() == 0 || sellTrailingStopPrice < Position.StopLoss() ) ) {
         ResetLastError();
         if ( !Trade.PositionModify( ticket, sellTrailingStopPrice, Position.TakeProfit() ) ) {
            err = GetLastError();
            PrintFormat( "Failed to update ts on ticket %I64u to %f, err=%i", ticket, sellTrailingStopPrice, err );
            }
        }
   }
}
