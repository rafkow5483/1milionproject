
//+------------------------------------------------------------------+
//|               MA100 + konfigurowalna MA50 BreakEven EA           |
//+------------------------------------------------------------------+
#property strict
#property version   "1.12"
#property description "Break-even po przecięciu MA_BreakEven (BUY: z góry w dół, SELL: z dołu w górę) + trailing po MA głównej"

#include <Trade/Trade.mqh>

// ── USTAWIENIA ───────────────────────────────────────────────────────────────
input int      InpMAPeriod            = 100;     // Okres głównej średniej (MA)
input int      InpMAPeriodBE          = 50;      // Okres średniej do break-even
input double   InpLots                = 0.10;    // Wielkość pozycji
input int      InpSL_Pips             = 20;      // Stały SL (pips) gdy tryb Fixed
enum SLMode { SL_Fixed=0, SL_FromMA=1 };
input SLMode   InpSLMode              = SL_FromMA; // Tryb SL
input int      InpSL_FromMA_Pips      = 20;      // Odległość SL od MA (pips)
input bool     InpMA_SL_Recalc        = true;    // Włącz trailing SL po MA
input int      InpTrailingFromMA_Pips = 15;      // Odległość trailing SL od MA (pips)
input int      InpTriggerOpenPips     = 20;      // Odległość od kotwicy do OTWARCIA
input int      InpTriggerClosePips    = 20;      // Odległość od kotwicy do ZAMKNIĘCIA
input bool     InpCloseOnMA           = true;    // Zamykanie na przecięciu MA tylko przy zysku
input long     InpMagic               = 20251010;// Magic Number

input bool enableTimePeriod1 = true; // Domyślnie włączone
input bool enableTimePeriod2 = true; // Domyślnie włączone

// Definicja zmiennych input dla czasów startu i końca
input int startHour1 = 6;
input int startMinute1 = 0;
input int endHour1 = 13;
input int endMinute1 = 0;

input int startHour2 = 15;
input int startMinute2 = 0;
input int endHour2 = 22;
input int endMinute2 = 0;


// Funkcja sprawdzająca, czy obecny czas mieści się w określonym przedziale
bool IsTimeToTrade() {
    MqlDateTime time;
    TimeToStruct(TimeCurrent(), time);

    // Konwersja do minut od północy
    int startTime1 = startHour1 * 60 + startMinute1;
    int endTime1 = endHour1 * 60 + endMinute1;
    int startTime2 = startHour2 * 60 + startMinute2;
    int endTime2 = endHour2 * 60 + endMinute2;
    int currentTime = time.hour * 60 + time.min;

    bool inTimePeriod1 = (currentTime >= startTime1 && currentTime <= endTime1) && enableTimePeriod1;
    bool inTimePeriod2 = (currentTime >= startTime2 && currentTime <= endTime2) && enableTimePeriod2;

    // Sprawdzenie czy bieżący czas mieści się w aktywnych przedziałach
    return inTimePeriod1 || inTimePeriod2;
}
// ── ZMIENNE ──────────────────────────────────────────────────────────────────
CTrade trade;
int      ma_handle = INVALID_HANDLE;
int      ma_handleBE = INVALID_HANDLE;
double   ma_buff[];
double   ma_buffBE[];

bool   anchorAboveActive = false;
double anchorAboveClose  = 0.0;
bool   anchorBelowActive = false;
double anchorBelowClose  = 0.0;

// ── POMOCNICZE ───────────────────────────────────────────────────────────────
double PipPoint()
{
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   return ((digits==3 || digits==5) ? 10.0*_Point : _Point);
}

double NormalizePrice(double price)
{
   return NormalizeDouble(price, (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS));
}

// BUY helpers
bool HasOpenBuyPosition()
{
   for(int i=PositionsTotal()-1; i>=0; --i)
      if(PositionSelectByTicket(PositionGetTicket(i)) &&
         PositionGetInteger(POSITION_MAGIC)==InpMagic &&
         PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)
         return true;
   return false;
}

ulong GetOpenBuyTicket()
{
   for(int i=PositionsTotal()-1; i>=0; --i)
   {
      ulong t=PositionGetTicket(i);
      if(PositionSelectByTicket(t) &&
         PositionGetInteger(POSITION_MAGIC)==InpMagic &&
         PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)
         return t;
   }
   return 0;
}

double CalcBuySL(double entryPrice, double ma_now, double pip)
{
   double sl;
   if(InpSLMode==SL_Fixed) sl = entryPrice - InpSL_Pips*pip;
   else                    sl = ma_now - MathMax(1, InpSL_FromMA_Pips)*pip;

   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double min_dist = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL)
                     *SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   if(sl > ask - min_dist) sl = ask - min_dist;
   return NormalizePrice(sl);
}

// SELL helpers
bool HasOpenSellPosition()
{
   for(int i=PositionsTotal()-1; i>=0; --i)
      if(PositionSelectByTicket(PositionGetTicket(i)) &&
         PositionGetInteger(POSITION_MAGIC)==InpMagic &&
         PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)
         return true;
   return false;
}

ulong GetOpenSellTicket()
{
   for(int i=PositionsTotal()-1; i>=0; --i)
   {
      ulong t=PositionGetTicket(i);
      if(PositionSelectByTicket(t) &&
         PositionGetInteger(POSITION_MAGIC)==InpMagic &&
         PositionGetString(POSITION_SYMBOL)==_Symbol &&
         PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)
         return t;
   }
   return 0;
}

double CalcSellSL(double entryPrice, double ma_now, double pip)
{
   double sl;
   if(InpSLMode==SL_Fixed) sl = entryPrice + InpSL_Pips*pip;
   else                    sl = ma_now + MathMax(1, InpSL_FromMA_Pips)*pip;

   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double min_dist = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL)
                     *SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   if(sl < bid + min_dist) sl = bid + min_dist;
   return NormalizePrice(sl);
}

// ── INIT/DEINIT ──────────────────────────────────────────────────────────────
int OnInit()
{
   trade.SetExpertMagicNumber(InpMagic);
   ma_handle   = iMA(_Symbol, _Period, InpMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
   ma_handleBE = iMA(_Symbol, _Period, InpMAPeriodBE, 0, MODE_SMA, PRICE_CLOSE);

   if(ma_handle==INVALID_HANDLE || ma_handleBE==INVALID_HANDLE)
   {
      Print("Błąd tworzenia iMA. Kod: ", GetLastError());
      return INIT_FAILED;
   }
   ArraySetAsSeries(ma_buff, true);
   ArraySetAsSeries(ma_buffBE, true);
   return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
   if(ma_handle!=INVALID_HANDLE) IndicatorRelease(ma_handle);
   if(ma_handleBE!=INVALID_HANDLE) IndicatorRelease(ma_handleBE);
}

// ── GŁÓWNA LOGIKA ────────────────────────────────────────────────────────────
void OnTick()
{
   if (!IsTimeToTrade()) return; // Jeśli nie, wyjdź z funkcji

   if(Bars(_Symbol,_Period) < InpMAPeriod+5) return;
   if(CopyBuffer(ma_handle,0,0,3,ma_buff) < 3) return;
   if(CopyBuffer(ma_handleBE,0,0,3,ma_buffBE) < 3) return;

   double pip = PipPoint();
   double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double ma0 = ma_buff[0];
   double maBE = ma_buffBE[0];
   double close = iClose(_Symbol, _Period, 0);
   double prevClose = iClose(_Symbol, _Period, 1);

   // ── wykrywanie przecięcia MA głównej ──
   if(close > ma0 && !anchorAboveActive)
   {
      anchorAboveActive = true;
      anchorAboveClose = close;
      anchorBelowActive = false;
   }
   else if(close < ma0 && !anchorBelowActive)
   {
      anchorBelowActive = true;
      anchorBelowClose = close;
      anchorAboveActive = false;
   }

   // ── BUY ENTRY ──
   if(anchorAboveActive && !HasOpenBuyPosition())
   {
      double triggerUp = anchorAboveClose + InpTriggerOpenPips*pip;
      if(ask >= triggerUp)
      {
         double sl = CalcBuySL(ask, ma0, pip);
         if(trade.Buy(InpLots, _Symbol, 0.0, sl, 0.0))
            anchorAboveActive = false;
      }
   }

   // ── BUY EXIT + BREAK-EVEN ──
   if(HasOpenBuyPosition())
   {
      ulong t = GetOpenBuyTicket();
      if(t && PositionSelectByTicket(t))
      {
         double entry = PositionGetDouble(POSITION_PRICE_OPEN);
         double cur_sl = PositionGetDouble(POSITION_SL);

         // Przecięcie MA_BreakEven z góry na dół i zejście 20 pips poniżej
         if(prevClose > maBE && close < maBE - 20*pip && cur_sl < entry)
         {
            trade.PositionModify(t, entry, PositionGetDouble(POSITION_TP));
            Print("BUY SL ustawiony na 0 po przecięciu MA_BE z góry w dół o 20 pipsów");
         }
      }
   }

   // ── SELL ENTRY ──
   if(anchorBelowActive && !HasOpenSellPosition())
   {
      double triggerDown = anchorBelowClose - InpTriggerOpenPips*pip;
      if(bid <= triggerDown)
      {
         double sl = CalcSellSL(bid, ma0, pip);
         if(trade.Sell(InpLots, _Symbol, 0.0, sl, 0.0))
            anchorBelowActive = false;
      }
   }

   // ── SELL EXIT + BREAK-EVEN ──
   if(HasOpenSellPosition())
   {
      ulong t = GetOpenSellTicket();
      if(t && PositionSelectByTicket(t))
      {
         double entry = PositionGetDouble(POSITION_PRICE_OPEN);
         double cur_sl = PositionGetDouble(POSITION_SL);

         // Przecięcie MA_BreakEven z dołu do góry i wybicie 20 pips powyżej
         if(prevClose < maBE && close > maBE + 20*pip && (cur_sl > entry || cur_sl==0))
         {
            trade.PositionModify(t, entry, PositionGetDouble(POSITION_TP));
            Print("SELL SL ustawiony na 0 po przecięciu MA_BE z dołu w górę o 20 pipsów");
         }
      }
   }

   // ── TRAILING SL po MA głównej ──
   if(InpMA_SL_Recalc)
   {
      if(HasOpenBuyPosition())
      {
         ulong t=GetOpenBuyTicket();
         if(t && PositionSelectByTicket(t))
         {
            double cur_sl=PositionGetDouble(POSITION_SL);
            double desired=ma0 - InpTrailingFromMA_Pips * pip;
            if(desired>cur_sl)
               trade.PositionModify(t, desired, PositionGetDouble(POSITION_TP));
         }
      }

      if(HasOpenSellPosition())
      {
         ulong t=GetOpenSellTicket();
         if(t && PositionSelectByTicket(t))
         {
            double cur_sl=PositionGetDouble(POSITION_SL);
            double desired=ma0 + InpTrailingFromMA_Pips * pip;
            if(desired<cur_sl || cur_sl<=0.0)
               trade.PositionModify(t, desired, PositionGetDouble(POSITION_TP));
         }
      }
   }
}
